!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Authors: Juhani Kataja
! *  Email:   juhani.kataja@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 26 Sep 2014
! *  Heavily inspired from MagnetoDynamics module.
! *****************************************************************************/
    
!------------------------------------------------------------------------------
!>  Solve Maxwell equations in vector potential formulation (or the A-V
!>  formulation) and (relatively)low frequency approximation using lowest
!>  order Withney 1-forms (edge elements).
!> \ingroup Solvers
!-------------------------------------------------------------------------------
MODULE VectorHelmholtzUtils

   USE DefUtils

   COMPLEX(KIND=dp), PARAMETER :: im = (0._dp,1._dp)

   INTERFACE SetDOFtoValue
     MODULE PROCEDURE SetDOFtoValueR, SetDOFtoValueC
   END INTERFACE

   INTERFACE GetInvPermeability
     MODULE PROCEDURE GetInvPermeabilityR, GetInvPermeabilityC
   END INTERFACE

   INTERFACE GetPermittivity
     MODULE PROCEDURE GetPermittivityR, GetPermittivityC ! , GetPermittivityCT ! >\todo: tensor version of permittivity material not done
  END INTERFACE

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION ComplexCrossProduct(v1,v2) RESULT(v3)
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp) :: v1(3), v2(3), v3(3)
    v3(1) =  v1(2)*v2(3) - v1(3)*v2(2)
    v3(2) = -v1(1)*v2(3) + v1(3)*v2(1)
    v3(3) =  v1(1)*v2(2) - v1(2)*v2(1)
!------------------------------------------------------------------------------
  END FUNCTION ComplexCrossProduct

!------------------------------------------------------------------------------
  FUNCTION GetBoundaryEdgeIndex(Boundary,nedge) RESULT(n)
!------------------------------------------------------------------------------
    INTEGER :: n,nedge
    TYPE(Element_t) :: Boundary
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,jb1,jb2,je1,je2
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Parent, Edge, Face
!------------------------------------------------------------------------------
    Mesh => GetMesh()
    n = 0
    SELECT CASE(GetElementFamily(Boundary))
    CASE(1)
      RETURN
    CASE(2)
      IF ( nedge==1 ) THEN
        Parent => Boundary % BoundaryInfo % Left
        IF ( .NOT. ASSOCIATED(Parent) ) &
            Parent => Boundary % BoundaryInfo % Right
 
        jb1 = Boundary % NodeIndexes(1)
        jb2 = Boundary % NodeIndexes(2)
        DO i=1,Parent % TYPE % NumberOfEdges
          Edge => Mesh % Edges(Parent % EdgeIndexes(i))
          je1 = Edge % NodeIndexes(1)
          je2 = Edge % NodeIndexes(2)
          IF ( jb1==je1.AND.jb2==je2 .OR. jb1==je2.AND.jb2==je1) EXIT
        END DO
        n = Parent % EdgeIndexes(i)
      END IF
    CASE(3,4)
      j = GetBoundaryFaceIndex(Boundary)
      Face => Mesh % Faces(j)
      IF ( nedge>0.AND.nedge<=Face % TYPE % NumberOfEdges ) &
        n = Face % EdgeIndexes(nedge) 
    END SELECT
!------------------------------------------------------------------------------
  END FUNCTION GetBoundaryEdgeIndex
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION GetBoundaryFaceIndex(Boundary) RESULT(n)
!------------------------------------------------------------------------------
    INTEGER :: n
    TYPE(Element_t) :: Boundary
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,m
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Parent, Face
!------------------------------------------------------------------------------
    Mesh => GetMesh()
    Parent => Boundary % BoundaryInfo % Left
    IF ( .NOT. ASSOCIATED(Parent) ) &
       Parent => Boundary % BoundaryInfo % Right

    DO i=1,Parent % TYPE % NumberOfFaces
      Face => Mesh % Faces(Parent % FaceIndexes(i))
      m = 0
      DO j=1,Face % TYPE % NumberOfNodes
        DO k=1,Boundary % TYPE % NumberOfNodes
          IF ( Face % NodeIndexes(j)==Boundary % NodeIndexes(k)) m=m+1
        END DO
      END DO
      IF ( m==Boundary % TYPE % NumberOfNodes) EXIT
    END DO
    n = Parent % FaceIndexes(i)
!------------------------------------------------------------------------------
  END FUNCTION GetBoundaryFaceIndex
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SetDOFToValueR(Solver,k,VALUE)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: VALUE,v
    TYPE(Solver_t) :: Solver
    INTEGER :: n,k
    TYPE(Matrix_t), POINTER :: A
    TYPE(Mesh_t), POINTER :: Mesh

    Mesh => GetMesh(Solver)
    n = Solver % Variable % Perm(k+Mesh % NumberOfNodes)
    A => GetMatrix()
    CALL CRS_SetSymmDirichlet(A,A % RHS,n,VALUE)
!------------------------------------------------------------------------------
  END SUBROUTINE SetDOFToValueR
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE SetDOFToValueC(Solver,k,VALUE)
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp) :: VALUE
    TYPE(Solver_t) :: Solver
    INTEGER :: n,k
    TYPE(Matrix_t), POINTER :: A
    TYPE(Mesh_t), POINTER :: Mesh

    Mesh => GetMesh(Solver)
    n = Solver % Variable % Perm(k+Mesh % NumberOfNodes)
    A => GetMatrix()
    CALL CRS_SetSymmDirichlet(A,A % RHS,2*(n-1)+1,REAL(VALUE))
    CALL CRS_SetSymmDirichlet(A,A % RHS,2*(n-1)+2,AIMAG(VALUE))
!------------------------------------------------------------------------------
  END SUBROUTINE SetDOFToValueC
!------------------------------------------------------------------------------

  SUBROUTINE GetPermittivityR(Material,Acoef,n)
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: Material
    INTEGER :: n
    REAL(KIND=dp) :: Acoef(:)
!------------------------------------------------------------------------------
    LOGICAL :: Found, FirstTime = .TRUE.
    REAL(KIND=dp) :: Avacuum

    SAVE Avacuum 

    IF ( FirstTime ) THEN
      Avacuum = GetConstReal( CurrentModel % Constants, &
        'Permittivity of Vacuum', Found )
      IF(.NOT. Found ) Avacuum = 8.854187817e-12
      FirstTime = .FALSE.
    END IF
  
    Acoef(1:n) = GetReal( Material, 'Relative Permittivity', Found )

    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)*Avacuum
    ELSE
      Acoef(1:n) = Avacuum
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE GetPermittivityR
!------------------------------------------------------------------------------

  SUBROUTINE GetPermittivityC(Material,Acoef,n)
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: Material
    INTEGER :: n
    COMPLEX(KIND=dp) :: Acoef(:)
!------------------------------------------------------------------------------
    LOGICAL :: Found, FirstTime = .TRUE.
    REAL(KIND=dp) :: Avacuum

    SAVE Avacuum 

    IF ( FirstTime ) THEN
      Avacuum = GetConstReal( CurrentModel % Constants, &
        'Permittivity of Vacuum', Found )
      IF(.NOT. Found ) Avacuum = 8.854187817e-12
      FirstTime = .FALSE.
    END IF


    
    Acoef(1:n) = GetReal( Material, 'Relative Permittivity', Found )
    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)
      Acoef(1:n) = CMPLX(REAL(Acoef(1:n)), &
        GetReal( Material, 'Relative Permittivity im', Found ), KIND=dp )
      Acoef(1:n) = Acoef(1:n)*Avacuum
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE GetPermittivityC
!------------------------------------------------------------------------------

!SUBROUTINE GetPermittivityCT(Material,Acoef,n)
!!------------------------------------------------------------------------------
    !TYPE(ValueList_t), POINTER :: Material
    !INTEGER :: n
    !COMPLEX(KIND=dp) :: Acoef(:,:,:)
    !LOGICAL :: Found, FirstTime = .TRUE. 
    !REAL(KIND=dp) :: permvacuum
!!------------------------------------------------------------------------------
    !SAVE permvacuum
    !Acoef = 0.0_dp

    !IF( FirstTime ) THEN
      !permvacuum = GetConstReal( CurrentModel % Constants, &
        !'Permittivity of Vacuum', Found)
      !IF(.NOT. Found ) permvacuum = 8.854187817e-12
      !FirstTime = .FALSE.
    !END IF
    !CALL ListGetRealArray( Material, &
      !'Relative Permittivity', Cwrk, 9, n
    !!Cwrk, n, Element & NodeIndexes, Found)
!END SUBROUTINE GetPermittivityCT

!------------------------------------------------------------------------------
 SUBROUTINE GetInvPermeabilityR(Material,Acoef,n)
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: Material
    INTEGER :: n
    REAL(KIND=dp) :: Acoef(:)
!------------------------------------------------------------------------------
    LOGICAL :: Found, FirstTime = .TRUE.
    REAL(KIND=dp) :: Avacuum

    SAVE Avacuum 

    IF ( FirstTime ) THEN
      Avacuum = GetConstReal( CurrentModel % Constants, &
              'Permeability of Vacuum', Found )
      IF(.NOT. Found ) Avacuum = PI * 4.0d-7
      FirstTime = .FALSE.
    END IF
  
    Acoef(1:n) = GetReal( Material, 'Inverse Relative Permeability', Found )
    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)/Avacuum
    ELSE
      Acoef(1:n) = GetReal( Material, 'Inverse Permeability', Found )
    END IF
    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE GetInvPermeabilityR
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
 SUBROUTINE GetInvPermeabilityC(Material,Acoef,n)
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: Material
    INTEGER :: n
    COMPLEX(KIND=dp) :: Acoef(:)
!------------------------------------------------------------------------------
    LOGICAL :: Found, FirstTime = .TRUE.
    REAL(KIND=dp) :: Avacuum

    SAVE Avacuum 

    IF ( FirstTime ) THEN
      Avacuum = GetConstReal( CurrentModel % Constants, &
              'Permeability of Vacuum', Found )
      IF(.NOT. Found ) Avacuum = PI * 4.0d-7
      FirstTime = .FALSE.
    END IF

    Acoef(1:n) = GetReal( Material, 'Inverse Relative Permeability', Found )
    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)/Avacuum
    END IF
    IF ( Found ) THEN
      Acoef(1:n) = Acoef(1:n)
      Acoef(1:n) = CMPLX(REAL(Acoef(1:n)), &
        GetReal( Material, 'Inverse Relative Permeability im', Found ), KIND=dp )
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE GetInvPermeabilityC
!------------------------------------------------------------------------------

END MODULE VectorHelmholtzUtils

!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE VectorHelmholtzSolver_Init0(Model,Solver,dt,Transient)
!------------------------------------------------------------------------------
  USE VectorHelmholtzUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------
  TYPE(ValueList_t), POINTER :: SolverParams
  LOGICAL :: Found, PiolaVersion

  SolverParams => GetSolverParams()
  IF ( .NOT.ListCheckPresent(SolverParams, "Element") ) THEN
    PiolaVersion = GetLogical(SolverParams, &
        'Use Piola Transform', Found )   
    IF (PiolaVersion) THEN    
       CALL ListAddString( SolverParams, "Element", "n:0 e:1 -brick b:3 -quad_face b:2" )
    ELSE
       CALL ListAddString( SolverParams, "Element", "n:0 e:1" )
    END IF
  END IF
! CALL ListAddString( SolverParams, "Exported Variable 1", &
!              "-dofs 2 -nooutput Jfix" )
!------------------------------------------------------------------------------
END SUBROUTINE VectorHelmholtzSolver_Init0
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!> Solve the electric field E from the rot-rot equation
! 
!> rot (1/mu_r) rot E - \kappa_0^2 epsilon_r E = i omega mu_0 J
!> mu
!
!>  using edge elements (Nedelec/W basis of lowest degree) 
!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE VectorHelmholtzSolver( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
  USE VectorHelmholtzUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  LOGICAL :: AllocationsDone = .FALSE., Found, L1
  TYPE(Element_t),POINTER :: Element, Edge

  REAL(KIND=dp) :: Norm, Omega
  TYPE(ValueList_t), POINTER :: BodyForce, Material, BC, BodyParams

  INTEGER :: n,nb,nd,t,istat,i,j,k,l,nNodes,Active,FluxCount=0
  INTEGER :: NoIterationsMin, NoIterationsMax

  TYPE(Mesh_t), POINTER :: Mesh

  COMPLEX(kind=dp) :: Aval
  COMPLEX(KIND=dp), ALLOCATABLE :: STIFF(:,:), MASS(:,:), FORCE(:)
  COMPLEX(KIND=dp), ALLOCATABLE :: LOAD(:,:), Acoef(:), Tcoef(:)  ! \TODO Acoef and Tcoef could be (1,1)-tensors
  REAL(KIND=dp), ALLOCATABLE :: RotM(:,:,:)

  COMPLEX(KIND=dp), ALLOCATABLE :: LamCond(:)

  REAL (KIND=DP), POINTER :: Cwrk(:,:,:), Cwrk_im(:,:,:), LamThick(:)

  REAL(KIND=dp), POINTER :: sValues(:), fixpot(:)
  TYPE(Variable_t), POINTER :: fixJpot

  CHARACTER(LEN=MAX_NAME_LEN):: LaminateStackModel, CoilType

  LOGICAL :: Stat, EigenAnalysis, TG, FixJ, LaminateStack, CoilBody, PiolaVersion, EdgeBasis,LFact,LFactFound
  INTEGER, POINTER :: Perm(:)
  INTEGER, ALLOCATABLE :: FluxMap(:)
  LOGICAL, ALLOCATABLE :: TreeEdges(:)

  TYPE(Matrix_t), POINTER :: A
  TYPE(ListMatrix_t), POINTER :: BasicCycles(:)

  SAVE STIFF, LOAD, MASS, FORCE, Tcoef, &
       Acoef, Cwrk, Cwrk_im, LamCond, &
       LamThick, AllocationsDone, RotM
!------------------------------------------------------------------------------
  PiolaVersion = GetLogical( GetSolverParams(), &
      'Use Piola Transform', Found )

  ! Allocate some permanent storage, this is done first time only:
  !---------------------------------------------------------------
  Mesh => GetMesh()
  nNodes = Mesh % NumberOfNodes
  Perm => Solver % Variable % Perm

  A => GetMatrix()

  IF ( .NOT. AllocationsDone ) THEN

     IF (Solver % Variable % dofs /= 2) THEN
       WRITE (Message, '(A,I3)') 'dofs:', Solver % Variable % dofs
       CALL Info ('VectorHelmholtzSolver_Init', Message)
       CALL Fatal ('VectorHelmholtzSolver_Init', &
         'Variable is not properly defined for Vectorial Helmholtz solver, Use: Variable = E[E re:1 E im:1]')
     ENDIF

     N = Mesh % MaxElementDOFs  ! just big enough
     ALLOCATE( FORCE(N), LOAD(3,N), STIFF(N,N), &
          MASS(N,N), Tcoef(N), RotM(3,3,N), &
          Acoef(N), LamCond(N), LamThick(N), &
          STAT=istat )
     IF ( istat /= 0 ) THEN
        CALL Fatal( 'VectorHelmholtzSolver', 'Memory allocation error.' )
     END IF

     NULLIFY( Cwrk )
     NULLIFY( Cwrk_im )

     AllocationsDone = .TRUE.
  END IF
  
  Omega = GetAngularFrequency(Found=Found)

  !
  ! Resolve internal non.linearities, if requeted:
  ! ----------------------------------------------
  NoIterationsMax = GetInteger( GetSolverParams(), &
              'Nonlinear System Max Iterations',Found)
  IF(.NOT. Found) NoIterationsMax = 1

  NoIterationsMin = GetInteger( GetSolverParams(), &
              'Nonlinear System Min Iterations',Found)
  IF(.NOT. Found) NoIterationsMin = 1

  LFact = GetLogical( GetSolverParams(),'Linear System Refactorize', LFactFound )
  EdgeBasis = .NOT.LFactFound .AND. GetLogical( GetSolverParams(), 'Edge Basis', Found )
  DO i=1,NoIterationsMax
    IF( DoSolve(i) ) THEN
      IF(i>=NoIterationsMin) EXIT
    END IF
    IF( EdgeBasis ) CALL ListAddLogical(GetSolverParams(),'Linear System Refactorize',.FALSE.)
  END DO
  IF ( EdgeBasis ) CALL ListRemove( GetSolverParams(), 'Linear System Refactorize' )

  CALL CalculateLumped(Model % NumberOfBodyForces)

CONTAINS

!---------------------------------------------------------------------------------------------
  FUNCTION DoSolve(IterNo) RESULT(Converged)
!---------------------------------------------------------------------------------------------
    INTEGER :: IterNo
    LOGICAL :: Converged
!---------------------------------------------------------------------------------------------
    REAL(KIND=dp) :: Norm, PrevNorm, TOL
    INTEGER :: i,j,k,n,nd,t
    REAL(KIND=dp), ALLOCATABLE :: Diag(:)
    LOGICAL  :: FoundMagnetization, Found
!---------------------------------------------------------------------------------------------
    ! System assembly:
    !-----------------
    CALL DefaultInitialize()
    Active = GetNOFActive()
    DO t=1,active
       Element => GetActiveElement(t)
       n  = GetElementNOFNodes() ! kulmat
       nd = GetElementNOFDOFs()  ! vapausasteet
  
       LOAD = 0.0d0
       BodyForce => GetBodyForce()
       FoundMagnetization = .FALSE.
       IF ( ASSOCIATED(BodyForce) ) THEN
          Load(1,1:n) = GetReal( BodyForce, 'Current Density 1', Found )
          Load(1,1:n) = CMPLX( REAL(Load(1,1:n)), &
            GetReal( BodyForce, 'Current Density im 1', Found ), KIND=dp)

          Load(2,1:n) = GetReal( BodyForce, 'Current Density 2', Found )
          Load(2,1:n) = CMPLX( REAL(Load(2,1:n)), & 
            GetReal( BodyForce, 'Current Density im 2', Found), KIND=dp)

          Load(3,1:n) = GetReal( BodyForce, 'Current Density 3', Found )
          Load(3,1:n) = CMPLX( REAL(Load(3,1:n)), &
            GetReal( BodyForce, 'Current Density im 3', Found), KIND=dp)
       END IF

       Material => GetMaterial( Element )

       Acoef = 0.0_dp
       Tcoef = 0.0_dp
       Material => GetMaterial( Element )

       IF ( ASSOCIATED(Material) ) THEN
         CALL GetInvPermeability(Material,Acoef,n)
         CALL GetPermittivity(Material,Tcoef,n)
       END IF

       BodyParams => GetBodyParams( Element )
       IF (.NOT. ASSOCIATED(BodyParams)) CALL Fatal ('VectorHelmholtzSolver', 'Body Parameters not found')

       Omega = GetAngularFrequency(Found=Found,UElement=Element)

       !Get element local matrix and rhs vector:
       !----------------------------------------
       CALL LocalMatrix( MASS, STIFF, FORCE, LOAD, &
          Tcoef, Acoef, Element, n, nd, PiolaVersion )

       !Update global matrix and rhs vector from local matrix & vector:
       !---------------------------------------------------------------
       CALL DefaultUpdateEquations( STIFF, FORCE, Element )
    END DO
    CALL DefaultFinishBulkAssembly()
    !
    ! Robin type of BC in terms of H:
    !--------------------------------
    Active = GetNOFBoundaryElements()
    DO t=1,Active
       Element => GetBoundaryElement(t)
       IF (.NOT. ActiveBoundaryElement()) CYCLE
       BC=>GetBC()
       IF (.NOT. ASSOCIATED(BC) ) CYCLE
     
       SELECT CASE(GetElementFamily())
       CASE(1)
         CYCLE
       CASE(2)
         k = GetBoundaryEdgeIndex(Element,1); Element => Mesh % Edges(k)
       CASE(3,4)
         k = GetBoundaryFaceIndex(Element)  ; Element => Mesh % Faces(k)
       END SELECT

       nd = GetElementNOFDOFs(Element)
       n  = GetElementNOFNodes(Element)
       Model % CurrentElement => Element 

       Load(1,1:n) = GetReal( BC, 'Magnetic Boundary Load 1', Found ) 
       Load(1,1:n) = CMPLX( REAL(Load(1,1:n)), &
          GetReal(BC, 'Magnetic Boundary Load im 1', Found), KIND=dp)

       Load(2,1:n) = GetReal( BC, 'Magnetic Boundary Load 2', Found )
       Load(2,1:n) = CMPLX( REAL(Load(2,1:n)), &
          GetReal(BC, 'Magnetic Boundary Load  im 2', Found), KIND=dp)

       Load(3,1:n) = GetReal( BC, 'Magnetic Boundary Load 3', Found )
       Load(3,1:n) = CMPLX( REAL(Load(3,1:n)), &
          GetReal(BC, 'Magnetic Boundary Load im 3', Found), KIND=dp)

       Acoef(1:n) = GetReal( BC, 'Electric Robin Coefficient', Found )
       Acoef(1:n) = CMPLX( REAL(Acoef(1:n)), &
         GetReal( BC, 'Electric Robin Coefficient im', Found), KIND=dp)

       CALL LocalMatrixBC(STIFF,FORCE,LOAD,Acoef,Element,n,nd,PiolaVersion)
       CALL DefaultUpdateEquations(STIFF,FORCE,Element)
    END DO

    CALL DefaultFinishAssembly()

    ! And finally, solve:
    !--------------------
  
    !
    ! Dirichlet BCs in terms of electric field E
    ! ---------------------------------------------
    IF (PiolaVersion) THEN
       CALL DefaultDirichletBCs(PiolaCurlTransform=.TRUE.)
    ELSE
       CALL DefaultDirichletBCs()
    END IF

    !
    ! Fix unused potential dofs:
    ! --------------------------
    A => GetMatrix()
    CALL ConstrainUnused(A)

    !
    ! Linear system solution:
    ! -----------------------
    Norm = DefaultSolve()
    Converged = Solver % Variable % NonlinConverged==1
!------------------------------------------------------------------------------
  END FUNCTION DoSolve
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE ConstrainUnused(A)
!------------------------------------------------------------------------------
    TYPE(Matrix_t) :: A
!------------------------------------------------------------------------------
    INTEGER :: i,j,n
   
    REAL(KIND=dp), ALLOCATABLE :: dDiag(:)
!------------------------------------------------------------------------------
    n = A % NumberOFRows
    ALLOCATE(dDiag(n)); dDiag=0._dp

    DO i=1,n,2
      j = A % Diag(i)
      IF(j>0) THEN
        dDiag(i)   =  A % Values(j)
        dDiag(i+1) = -A % Values(j+1)
      END IF
    END DO
    IF (ParEnv % PEs>1) CALL ParallelSumVector(A, dDiag)

    n = Mesh % NumberOfNodes
    DO i=1,SIZE(Solver % Variable % Perm) !n
      j = Solver % Variable % Perm(i)
      IF (j==0) CYCLE

      j = 2*(j-1)
      Aval = CMPLX(dDiag(j+1), dDiag(j+2), KIND=dp)

      IF (Aval==0._dp) THEN
        A % RHS(j+1) = 0._dp
        CALL ZeroRow(A,j+1)
        A % Values(A % Diag(j+1)) = 1._dp

        A % RHS(j+2) = 0._dp
        CALL ZeroRow(A,j+2)
        A % Values(A % Diag(j+2)) = 1._dp

        IF(ALLOCATED(A % ConstrainedDOF)) THEN
          A % ConstrainedDOF(j+1) = .TRUE.
          A % ConstrainedDOF(j+2) = .TRUE.
        END IF
      END IF
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE ConstrainUnused
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
 SUBROUTINE CalculateLumped(nbf)
!------------------------------------------------------------------------------
   INTEGER::nbf
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: a(nbf),IMoment,IA
   INTEGER :: i,bfid,n,nd
   TYPE(Element_t), POINTER :: Element, Parent
   COMPLEX(KIND=dp) :: torq, U(nbf), zforce, zzforce
   LOGICAL :: Found, CalcTorque,CalcPotential,CalcInertia
   TYPE(ValueList_t),POINTER::Params
!------------------------------------------------------------------------------

   CalcTorque = ListCheckPresentAnyBody(Model,'r inner')
   CalcPotential = ListGetLogicalAnyBodyForce( Model,'Calculate Potential')
   CalcInertia = ListGetLogicalAnyBody( Model,'Calculate Inertial Moment')

   IF(.NOT. (CalcTorque .OR. CalcPotential .OR. CalcInertia ) ) RETURN

   U=0._dp; a=0._dp; torq=0._dp; IMoment=0._dp;IA=0; zforce=0
   DO i=1,GetNOFActive()
     Element => GetActiveElement(i)
     nd = GetElementNOFDOFs(Element)
     n  = GetElementNOFNodes(Element)

     IF( CalcTorque ) THEN
       CALL Torque(Torq,Element,n,nd)
       CALL AxialForce(zforce,Element,n,nd)
     END IF

     IF( CalcPotential ) THEN
       Params=>GetBodyForce(Element)
       IF(ASSOCIATED(Params)) THEN
         bfid=GetBodyForceId(Element)
         IF(GetLogical(Params,'Calculate Potential',Found)) &
             CALL Potential(u(bfid),a(bfid),Element,n,nd)
       END IF
     END IF

     IF( CalcInertia ) THEN
       Params=>GetBodyParams(Element)
       IF(ASSOCIATED(Params)) THEN
         IF(GetLogical(Params,'Calculate Inertial Moment',Found)) &
             CALL InertialMoment(IMoment,IA,Element,n,nd)
       END IF
     END IF
   END DO

   zzforce = 0
   IF(ListGetLogicalAnyBC(Model,'Calculate Axial Force')) THEN
     DO i=1,Mesh % NumberOFBoundaryElements
       Element => GetBoundaryElement(i)
       IF (.NOT.GetLogical(GetBC(), 'Calculate Axial Force', Found ) ) CYCLE

       Parent => Element % BoundaryInfo % Left
       n  = GetELementNofNodes(Parent)
       nd = GetELementNofDOFs(Parent)
       CALL AxialForceSurf(zzforce,Element,n,nd)
     END DO
   END IF

   IF( CalcPotential ) THEN
     DO i=1,nbf
       a(i) = ParallelReduction(a(i))
       u(i) = CMPLX( ParallelReduction(REAL(u(i))),ParallelReduction(AIMAG(u(i))) )
     END DO
     
     DO i=1,nbf
       IF(a(i)>0) THEN
         CALL ListAddConstReal(Model % Simulation,'res: Potential re / bodyforce ' &
             //TRIM(i2s(i)),REAL(u(i))/a(i))
         CALL ListAddConstReal(Model % Simulation,'res: Potential im / bodyforce ' &
             //TRIM(i2s(i)),AIMAG(u(i))/a(i))
         CALL ListAddConstReal(Model % Simulation,'res: area / bodyforce ' &
             //TRIM(i2s(i)),a(i))
       END IF
     END DO
   END IF

   IF( CalcTorque ) THEN
     Torq = CMPLX( ParallelReduction(REAL(Torq)), ParallelReduction(AIMAG(Torq)) )
     CALL ListAddConstReal(Model % Simulation,'res: Air Gap Torque re', REAL(Torq))
     CALL ListAddConstReal(Model % Simulation,'res: Air Gap Torque im', AIMAG(Torq))

     zforce = CMPLX( ParallelReduction(REAL(zforce)), ParallelReduction(AIMAG(zforce)) )
     CALL ListAddConstReal(Model % Simulation,'res: Axial force(vol) re', REAL(zforce))
     CALL ListAddConstReal(Model % Simulation,'res: Axial force(vol) im', AIMAG(zforce))

   zzforce = 0
   IF(ListGetLogicalAnyBC(Model,'Calculate Axial Force')) THEN
     DO i=1,Mesh % NumberOFBoundaryElements
       Element => GetBoundaryElement(i)
       IF (.NOT.GetLogical(GetBC(), 'Calculate Axial Force', Found ) ) CYCLE

       Parent => Element % BoundaryInfo % Left
       n  = GetELementNofNodes(Parent)
       nd = GetELementNofDOFs(Parent)
       CALL AxialForceSurf(zzforce,Element,n,nd)
     END DO
   END IF
     IF(ListGetLogicalAnyBC(Model,'Calculate Axial Force')) THEN
       zzforce = CMPLX( ParallelReduction(REAL(zzforce)), ParallelReduction(AIMAG(zzforce)) )
       CALL ListAddConstReal(Model % Simulation,'res: Axial force(surf) re', REAL(zzforce))
       CALL ListAddConstReal(Model % Simulation,'res: Axial force(surf) im', AIMAG(zzforce))
     END IF
   END IF

   IF( CalcInertia ) THEN
     IMoment = ParallelReduction(IMoment)
     IA = ParallelReduction(IA)
     CALL ListAddConstReal(Model % Simulation,'res: Inertial Volume', IA)
     CALL ListAddConstReal(Model % Simulation,'res: Inertial Moment', IMoment)
   END IF

!------------------------------------------------------------------------------
 END SUBROUTINE CalculateLumped
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE InertialMoment(U,A,Element,n,nd)
!------------------------------------------------------------------------------
    INTEGER :: n,nd
    REAL(KIND=dp)::U,a
    TYPE(Element_t)::Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n), DetJ,x,y,r,Density(n)
    INTEGER :: t
    LOGICAL :: stat,Found
    TYPE(Nodes_t), SAVE :: Nodes
    TYPE(GaussIntegrationPoints_t) :: IP
	!$OMP THREADPRIVATE(Nodes)

    Density(1:n) = GetReal(GetMaterial(),'Density',Found,Element)
    IF(.NOT.Found) RETURN

    CALL GetElementNodes( Nodes, Element )
  
    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element)
    DO t=1,IP % n
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
                IP % W(t), detJ, Basis )

      x = SUM(Nodes % x(1:n)*Basis(1:n))
      y = SUM(Nodes % y(1:n)*Basis(1:n))
      r = SQRT(x**2+y**2)
      A = A + IP % s(t)*detJ
      U = U + IP % s(t)*detJ*R*SUM(Density(1:n)*Basis(1:n))
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE InertialMoment
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE Torque(U,Element,n,nd)
!------------------------------------------------------------------------------
    INTEGER :: n,nd
    COMPLEX(KIND=dp)::U
    TYPE(Element_t)::Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: dBasisdx(nd,3),Basis(nd), DetJ, &
             POT(2,nd),x,y,r,r0,r1,Wbasis(nd,3),RotWBasis(nd,3)
    COMPLEX(KIND=dp) :: B(3,nd), POTC(nd), Br, Bp, Bx, By
    INTEGER :: t
    LOGICAL :: stat, Found
    TYPE(Nodes_t), SAVE :: Nodes
    TYPE(GaussIntegrationPoints_t) :: IP
	!$OMP THREADPRIVATE(Nodes)

    r0 = GetCReal(GetBodyParams(),'r inner',Found)
    r1 = GetCReal(GetBodyParams(),'r outer',Found)
    IF (.NOT.Found) RETURN

    CALL GetElementNodes( Nodes, Element )

    x = SUM(Nodes % x(1:n))/n
    y = SUM(Nodes % y(1:n))/n
    r = SQRT(x**2+y**2)
    IF (r<r0.OR.r>r1) RETURN

    CALL GetLocalSolution(POT, UElement=Element)
    POTC = CMPLX( POT(1,1:nd), POT(2,1:nd) )
  
    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)
    DO t=1,IP % n
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      IF (PiolaVersion) THEN
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), IP % W(t), &
            detJ, Basis, dBasisdx,EdgeBasis=WBasis, RotBasis=RotWBasis )
      ELSE
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
                  IP % W(t), detJ, Basis, dBasisdx )
        CALL GetEdgeBasis(Element,WBasis,RotWBasis,Basis,dBasisdx)
      END IF

      x = SUM(Nodes % x(1:n)*Basis(1:n))
      y = SUM(Nodes % y(1:n)*Basis(1:n))
      r = SQRT(x**2+y**2)

      Bx =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,1))
      By =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,2))
      Br =  x/r*Bx + y/r*By
      Bp = -y/r*Bx + x/r*By
      U = U + IP % s(t) * detJ * r * &
           CMPLX(REAL(Br)*REAL(Bp),AIMAG(Br)*AIMAG(Bp))/(PI*4.0d-7*(r1-r0))
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE Torque
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AxialForce(U,Element,n,nd)
!------------------------------------------------------------------------------
    INTEGER :: n,nd
    COMPLEX(KIND=dp)::U
    TYPE(Element_t)::Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: dBasisdx(nd,3),Basis(nd), DetJ, &
             POT(2,nd),x,y,r,r0,r1,Wbasis(nd,3),RotWBasis(nd,3)
    COMPLEX(KIND=dp) :: B(3,nd), POTC(nd), Bx, By, Bz, Br, Bp
    INTEGER :: t
    LOGICAL :: stat, Found
    TYPE(Nodes_t), SAVE :: Nodes
    TYPE(GaussIntegrationPoints_t) :: IP
	!$OMP THREADPRIVATE(Nodes)

    r0 = GetCReal(GetBodyParams(),'r inner',Found)
    r1 = GetCReal(GetBodyParams(),'r outer',Found)
    IF (.NOT.Found) RETURN

    CALL GetElementNodes( Nodes, Element )

    x = SUM(Nodes % x(1:n))/n
    y = SUM(Nodes % y(1:n))/n
    r = SQRT(x**2+y**2)
    IF (r<r0.OR.r>r1) RETURN

    CALL GetLocalSolution(POT, UElement=Element)
    POTC = CMPLX( POT(1,1:nd), POT(2,1:nd) )
  
    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)
    DO t=1,IP % n
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      IF (PiolaVersion) THEN
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), IP % W(t), &
            detJ, Basis, dBasisdx,EdgeBasis=WBasis, RotBasis=RotWBasis )
      ELSE
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
                  IP % W(t), detJ, Basis, dBasisdx )
        CALL GetEdgeBasis(Element,WBasis,RotWBasis,Basis,dBasisdx)
      END IF

      x = SUM(Nodes % x(1:n)*Basis(1:n))
      y = SUM(Nodes % y(1:n)*Basis(1:n))
      r = SQRT(x**2+y**2)
      x = x/r; y=y/r

      Bx =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,1))
      By =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,2))
      Bz =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,3))
      U = U + IP % s(t) * detJ * 1 * &
           CMPLX((REAL(Bx)*REAL(Bz)*x + REAL(By)*REAL(Bz)*y), &
                (AIMAG(Bx)*AIMAG(Bz)*x + AIMAG(By)*AIMAG(Bz)*y)) &
               /(PI*4.0d-7*(r1-r0))
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE AxialForce
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AxialForceSurf(U,Element,n,nd)
!------------------------------------------------------------------------------
    INTEGER :: n,nd
    COMPLEX(KIND=dp)::U
    TYPE(Element_t)::Element
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER ::PARENT
    REAL(KIND=dp) :: dBasisdx(nd,3),Basis(nd), DetJ, Pdetj, uu,v,w, &
             POT(2,nd),x,y,r,r0,r1,Wbasis(nd,3),RotWBasis(nd,3)
    COMPLEX(KIND=dp) :: B(3,nd), POTC(nd), Bx, By, Bz
    INTEGER :: t
    LOGICAL :: stat, Found
    TYPE(Nodes_t), SAVE :: Nodes, PNodes
    TYPE(GaussIntegrationPoints_t) :: IP
	!$OMP THREADPRIVATE(Nodes)

    CALL GetElementNodes( Nodes, Element )
    Parent => Element % BoundaryInfo % Left
    CALL GetElementNodes( PNodes, Parent )

    CALL GetLocalSolution(POT, UElement=Parent )
    POTC = CMPLX( POT(1,1:nd), POT(2,1:nd) )
  
    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)
    DO t=1,IP % n
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      IF (PiolaVersion) THEN
        CALL Warn('AxialForceSurf', 'Surface force not implemented for Piola Elements')
        RETURN
!       stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), IP % W(t), &
!           detJ, Basis, dBasisdx,EdgeBasis=WBasis, RotBasis=RotWBasis )
      ELSE

        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
                  IP % W(t), detJ, Basis, dBasisdx )

        CALL GetParentUVW(Element,GetElementNOFNodes(Element),Parent,n,uu,v,w,Basis)
        stat = ElementInfo( Parent, PNodes, uu,v,w, pdetJ, Basis, dBasisdx )

        CALL GetEdgeBasis(Parent,WBasis,RotWBasis,Basis,dBasisdx)
      END IF

      x = SUM(Basis(1:n) * PNodes % x(1:n))
      y = SUM(Basis(1:n) * PNodes % y(1:n))
      r = SQRT(x**2 + y**2)
      x=x/r; y=y/r

      Bx =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,1))
      By =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,2))
      Bz =  SUM(POTC(n+1:nd) * RotWBasis(1:nd-n,3))
      U = U + IP % s(t) * detJ * &
           CMPLX((REAL(Bx)*REAL(Bz)*x + REAL(By)*REAL(Bz)*y), &
                (AIMAG(Bx)*AIMAG(Bz)*x + AIMAG(By)*AIMAG(Bz)*y)) /(PI*4.0d-7)
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE AxialForceSurf
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE Potential( U, A, Element,n,nd)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: A
    COMPLEX(KIND=dp) :: U
    INTEGER :: n, nd
    TYPE(Element_t), POINTER :: Element

    REAL(KIND=dp) :: Basis(nd), dBasisdx(nd,3),DetJ,POT(2,nd), &
          wBasis(nd,3),rotWBasis(nd,3),Wpot(nd),w(3), Omega
    COMPLEX(KIND=dp) :: POTC(nd)
    INTEGER :: t
    LOGICAL :: stat, WbaseFound
    TYPE(Nodes_t), SAVE :: Nodes
    TYPE(GaussIntegrationPoints_t) :: IP
	!$OMP THREADPRIVATE(Nodes)

    CALL GetElementNodes( Nodes )

    Omega = GetAngularFrequency(UElement=Element)
    CALL GetLocalSolution(POT,UElement=Element)
    POTC = Omega*CMPLX( POT(2,1:nd), POT(1,1:nd) )

    CALL GetLocalSolution(Wpot,'W',UElement=Element)
    W = [0._dp, 0._dp, 1._dp]
    WbaseFound = ANY(Wpot(1:n)/=0._dp)

    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)
    DO t=1,IP % n
      ! Basis function values & derivatives at the integration point:
      !--------------------------------------------------------------
      IF (PiolaVersion) THEN
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), IP % W(t), &
           detJ, Basis, dBasisdx,EdgeBasis=WBasis, RotBasis=RotWBasis )
      ELSE
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
                  IP % W(t), detJ, Basis, dBasisdx )
        CALL GetEdgeBasis(Element,WBasis,RotWBasis,Basis,dBasisdx)
      END IF

      IF(WBaseFound) W = MATMUL(Wpot(1:n),dBasisdx(1:n,:))

      A = A + IP % s(t) * detJ
      U = U + IP % s(t) * detJ * SUM(PotC(n+1:nd)*MATMUL(WBasis(1:nd-n,:),w))
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE Potential
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE GaugeTree()
!------------------------------------------------------------------------------
    TYPE(ListMatrixEntry_t), POINTER :: Aentry
    TYPE(ListMatrix_t), POINTER :: Alist(:)
    INTEGER :: i,j,k,l,n,Start
    LOGICAL, ALLOCATABLE :: Done(:)
    TYPE(Element_t), POINTER :: Edge, Boundary
!------------------------------------------------------------------------------

    IF ( .NOT. ALLOCATED(TreeEdges) ) THEN
      ALLOCATE(TreeEdges(Mesh % NumberOfEdges)); TreeEdges=.FALSE.
    END IF

    n = Mesh % NumberOfNodes
    ALLOCATE(Done(n)); Done=.FALSE.

    ! 
    ! Skip Dirichlet BCs in terms of A:
    ! ---------------------------------
    DO i=1,Mesh % NumberOfBoundaryElements
      Boundary => GetBoundaryElement(i)
      IF ( .NOT.ActiveBoundaryElement()) CYCLE
      IF ( GetElementFamily()==1 ) CYCLE
      BC => GetBC()
      IF (.NOT.ASSOCIATED(BC)) CYCLE
      IF (.NOT.ListCheckPresent( BC, &
           TRIM(Solver % Variable % Name)//' {e}')) CYCLE
 
      j=1; k=GetBoundaryEdgeIndex(Boundary,j)
      DO WHILE(k>0)
        Edge => Mesh % Edges(k)
        Done(Edge % NodeIndexes) = .TRUE.
        j=j+1; k=GetBoundaryEdgeIndex(Boundary,j)
      END DO
    END DO

    ! 
    ! Skip Dirichlet BCs in terms of B:
    ! ---------------------------------
    DO i=1,FluxCount
      j = FluxMap(i)
      IF ( Perm(j+n)<=0 ) CYCLE
      Edge => Mesh % Edges(j)
      Done(Edge % NodeIndexes)=.TRUE.
    END DO

    !
    ! node -> edge list
    ! -----------------
    Alist => NULL()
    n = Mesh % NumberOfNodes
    DO i=1,Mesh % NumberOfEdges
      Edge => Mesh % Edges(i)
      IF ( Perm(i+n)<=0 ) CYCLE
      DO j=1,Edge % TYPE % NumberOfNodes
        k=Edge % NodeIndexes(j)
        Aentry=>List_GetMatrixIndex(Alist,k,i)
      END DO
    END DO

    !
    ! generate the tree for all (perhaps disconnected) parts:
    ! -------------------------------------------------------
    DO WHILE(.NOT.ALL(Done))
      DO Start=1,n
        IF (.NOT. Done(Start)) EXIT
      END DO
      CALL DepthFirstSearch(Alist,Done,Start)
    END DO
    DEALLOCATE(Done)
    CALL List_FreeMatrix(SIZE(Alist),Alist)
!------------------------------------------------------------------------------
  END SUBROUTINE GaugeTree
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE GaugeTreeFluxBC()
!------------------------------------------------------------------------------
    TYPE(ListMatrixEntry_t), POINTER :: Aentry, Ltmp
    TYPE(ListMatrix_t), POINTER :: Alist(:)
    INTEGER :: i,j,k,l,n,Start,nCount,fixedge
    LOGICAL, ALLOCATABLE :: Done(:)
    INTEGER, ALLOCATABLE :: NodeList(:)
    TYPE(Element_t), POINTER :: Edge, Boundary
!------------------------------------------------------------------------------
    IF ( .NOT. ALLOCATED(TreeEdges) ) THEN
      ALLOCATE(TreeEdges(Mesh % NumberOfEdges)); TreeEdges=.FALSE.
    END IF

    n = Mesh % NumberOfNodes
    ALLOCATE(Done(n)); Done=.FALSE.

    !
    ! list the candidate nodes:
    ! -------------------------
    DO i=1,FluxCount
      j = FluxMap(i)
      Edge => Mesh % Edges(j)
      Done(Edge % NodeIndexes)=.TRUE.
    END DO

    ALLOCATE(NodeList(COUNT(Done)))
    nCount = 0
    DO i=1,n
      IF ( Done(i) ) THEN
        nCount = nCount+1
        NodeList(nCount)=i
      END IF
    END DO

    Done=.FALSE.
    DO i=1,FluxCount
      IF ( TreeEdges(FluxMap(i)) ) THEN
        Edge => Mesh % Edges(FluxMap(i))
        Done(Edge % NodeIndexes)=.TRUE.
      END IF
    END DO

    ! 
    ! Skip Dirichlet BCs in terms of A:
    ! ---------------------------------
    DO i=1,Mesh % NumberOfBoundaryElements
      Boundary => GetBoundaryElement(i)
      IF ( .NOT.ActiveBoundaryElement()) CYCLE
      IF ( GetElementFamily()==1 ) CYCLE
      BC => GetBC()
      IF (.NOT.ASSOCIATED(BC)) CYCLE
      IF (.NOT.ListCheckPresent( BC, &
           TRIM(Solver % Variable % Name)//' {e}')) CYCLE
 
      j=1; k=GetBoundaryEdgeIndex(Boundary,j)
      DO WHILE(k>0)
        Edge => Mesh % Edges(k)
        TreeEdges(k) = .TRUE.
        Done(Edge % NodeIndexes) = .TRUE.
        j=j+1; k=GetBoundaryEdgeIndex(Boundary,j)
      END DO
    END DO

    ! node -> edge list
    ! -----------------
    Alist => NULL()
    DO i=1,FluxCount
      j = FluxMap(i)
      IF ( Perm(j+n)<=0 ) CYCLE

      Edge => Mesh % Edges(j)
      DO k=1,Edge % TYPE % NumberOfNodes
        l=Edge % NodeIndexes(k)
        Aentry=>List_GetMatrixIndex(Alist,l,j)
      END DO
    END DO
 
    ! generate the tree for all (perhaps disconnected) parts:
    ! -------------------------------------------------------
    DO WHILE(.NOT.ALL(Done(NodeList)))
      DO i=1,nCount
        Start = NodeList(i)
        IF ( .NOT. Done(Start) ) EXIT
      END DO
      CALL BreadthFirstSearch(Alist,Done,start,nCount,NodeList)
    END DO
    DEALLOCATE(Done,NodeList)
    CALL List_FreeMatrix(SIZE(Alist),Alist)
!------------------------------------------------------------------------------
  END SUBROUTINE GaugeTreeFluxBC
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE BreadthFirstSearch(Alist,done,start,nCount,NodeList)
!------------------------------------------------------------------------------
    INTEGER :: start,nCount,NodeList(:)
    LOGICAL :: Done(:)
    TYPE(ListMatrix_t) :: Alist(:)
!------------------------------------------------------------------------------
    TYPE(ListMatrixEntry_t), POINTER :: Aentry, Ltmp, Btmp
    INTEGER :: i,j,k,l,n,m,ll,IF,bcycle
    TYPE(Element_t), POINTER :: Edge,Edge1,Boundary
    LOGICAL, ALLOCATABLE :: DoneL(:)
    INTEGER, ALLOCATABLE :: Fifo(:), Previous(:), FiFo1(:)
!------------------------------------------------------------------------------
   ALLOCATE(DoneL(Mesh % NumberOfEdges)); DoneL=.FALSE.
   ALLOCATE(Fifo(FluxCount),FiFo1(FluxCount))
   ALLOCATE(Previous(Mesh % NumberOfNodes)); Previous=0;

   IF = 0; m=0
   DO i=1,nCount
     j = NodeList(i)
     IF ( Done(j) ) THEN
       m=m+1; fifo1(m)=j
       IF=IF+1; fifo(IF)=j
     END IF
   END DO

   IF ( IF>0 ) THEN
     DO WHILE(m>0)
       j = Fifo1(m); m=m-1

       Aentry => Alist(j) % Head
       DO WHILE(ASSOCIATED(Aentry))
         k = Aentry % Index
         Aentry => Aentry % Next

         Edge => Mesh % Edges(k)
         IF (.NOT. TreeEdges(k) .OR. DoneL(k) ) CYCLE
         DoneL(k)=.TRUE.

         l = Edge % NodeIndexes(1)
         IF (l==j) l=Edge % NodeIndexes(2)

         IF=IF+1; Fifo(IF)=l
         m=m+1; Fifo1(m)=l
         Previous(l)=j
       END DO
     END DO
     Start = l
   END IF
   
   IF ( IF==0 ) THEN
     Done(Start)=.TRUE.
     IF=1; fifo(IF)=start;
   END IF

   Bcycle=0;
   ALLOCATE(BasicCycles(FluxCount))
   BasicCycles(:) % Degree = 0
   DO i=1,FluxCount
     BasicCycles(i) % Head => NULL()
   END DO

   DO WHILE(IF>0)
     j = Fifo(IF); IF=IF-1

     Aentry => Alist(j) % Head
     DO WHILE(ASSOCIATED(Aentry))
       k = Aentry % Index
       Aentry => Aentry % Next

       Edge => Mesh % Edges(k)
       IF ( DoneL(k) ) CYCLE
       DoneL(k)=.TRUE.

       l = Edge % NodeIndexes(1)
       IF (l==j) l=Edge % NodeIndexes(2)

       IF ( Done(l) ) THEN
         ! Generate fundamental cycle
         bcycle = bcycle+1
         CALL AddToCycle(bcycle,k)

         m = j
         DO WHILE(m/=Previous(l))
           Ltmp => Alist(m) % Head
           DO WHILE(ASSOCIATED(Ltmp))
             Edge1 => Mesh % Edges(Ltmp % Index)
             IF ( ANY(Edge1 % NodeIndexes(1:2)==Previous(m)) ) THEN
               CALL AddToCycle(bcycle,Ltmp % Index); EXIT
             END IF
             Ltmp=>Ltmp % Next
           END DO
           IF ( ANY(Edge1 % NodeIndexes(1:2) == l) ) EXIT
           m = Previous(m)
         END DO

         IF ( ALL(Edge1 % NodeIndexes(1:2) /= l) ) THEN
           ltmp => Alist(l) % Head
           DO WHILE(ASSOCIATED(ltmp))
             edge1 => Mesh % Edges(Ltmp % Index)
             IF ( ANY(Edge1 % NodeIndexes(1:2)==Previous(l)) ) THEN
               CALL AddToCycle(bcycle,Ltmp % Index); EXIT
             END IF
             ltmp=>ltmp % Next
           END DO
         END IF
       ELSE
         IF (.NOT.TreeEdges(k)) CALL SetDOFToValue(Solver,k,(0._dp,0._dp))
         IF=IF+1; Fifo(IF)=l
         Previous(l)=j
         Done(l)=.TRUE.
         TreeEdges(k) = .TRUE.
       END IF
     END DO
   END DO
   DEALLOCATE(Fifo, Fifo1, DoneL)
!------------------------------------------------------------------------------
  END SUBROUTINE BreadthFirstSearch
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddToCycle(bcycle,index)
    INTEGER :: bcycle,index
!------------------------------------------------------------------------------
    TYPE(ListMatrixEntry_t), POINTER :: Btmp

    ALLOCATE(Btmp); Btmp % Next => BasicCycles(bcycle) % Head;
    Btmp % Index = index; BasicCycles(bcycle) % Head => Btmp
    BasicCycles(bcycle) % Degree=BasicCycles(bcycle) % Degree+1
!------------------------------------------------------------------------------
  END SUBROUTINE AddToCycle
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  RECURSIVE SUBROUTINE DepthFirstSearch(Alist,done,i)
!------------------------------------------------------------------------------
    TYPE(ListMatrix_t) :: Alist(:)
    INTEGER :: i
    LOGICAL :: Done(:)
!------------------------------------------------------------------------------
    TYPE(ListMatrixEntry_t), POINTER :: Aentry
    INTEGER :: j,k,l,n
    TYPE(Element_t), POINTER :: Edge
!------------------------------------------------------------------------------
    ! To give better matrix conditioning some directional heuristics
    ! could be added,e.g. select the order of going through the nodes
    ! edge list here:

    Done(i) = .TRUE.

    Aentry => Alist(i) % Head
    DO WHILE(ASSOCIATED(Aentry))
      k = Aentry % Index
      Aentry => Aentry % Next

      Edge => Mesh % Edges(k)
      IF (ALL(Done(Edge % NodeIndexes))) CYCLE

      IF ( .NOT. TreeEdges(k)) CALL SetDOFToValue(Solver,k,(0._dp,0._dp))
      TreeEdges(k)=.TRUE.
      DO l=1,2
        n = Edge % NodeIndexes(l)
        IF (.NOT. Done(n)) CALL DepthFirstSearch(Alist,done,n)
      END DO
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE DepthFirstSearch
!------------------------------------------------------------------------------

!-----------------------------------------------------------------------------
  SUBROUTINE LocalMatrix( MASS, STIFF, FORCE, LOAD, &
            Tcoef, Acoef, Element, n, nd, PiolaVersion )
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp) :: STIFF(:,:), FORCE(:), MASS(:,:)
    COMPLEX(KIND=dp) :: LOAD(:,:), Tcoef(:), Acoef(:)!, &
    INTEGER :: n, nd
    TYPE(Element_t), POINTER :: Element
    LOGICAL :: PiolaVersion

    REAL(KIND=dp) :: WBasis(nd,3), RotWBasis(nd,3)
    COMPLEX(KIND=dp) :: eps, muinv, C(3,3), L(3), G(3), M(3), FixJPotC(n)
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),DetJ,FixJPot(2,nd)

    REAL(KIND=dp) :: skind, babs, muder, AlocR(2,nd)

    LOGICAL :: Stat
    INTEGER :: t, i, j, p, q, np, siz
    TYPE(GaussIntegrationPoints_t) :: IP

    REAL(KIND=dp), POINTER :: Bval(:), Hval(:), Cval(:),  &
           CubicCoeff(:)=>NULL(),HB(:,:)=>NULL()
    TYPE(ValueList_t), POINTER :: Lst

    TYPE(Nodes_t), SAVE :: Nodes
    LOGICAL :: FirstTime = .TRUE.

    CALL GetElementNodes( Nodes, Element )

    STIFF = 0.0_dp
    FORCE = 0.0_dp
    MASS  = 0.0_dp

    !Numerical integration:
    !----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)

    DO t=1,IP % n
       IF (PiolaVersion) THEN
          stat = EdgeElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
               IP % W(t), DetF = DetJ, Basis = Basis, EdgeBasis = WBasis, &
               RotBasis = RotWBasis, dBasisdx = dBasisdx, &
               ApplyPiolaTransform = .TRUE.)
       ELSE
          stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
               IP % W(t), detJ, Basis, dBasisdx )

          CALL GetEdgeBasis(Element, WBasis, RotWBasis, Basis, dBasisdx)
       END IF

       muinv = SUM( Basis(1:n) * Acoef(1:n) )
       eps = SUM( Basis(1:n) * Tcoef(1:n) )

       L = MATMUL( LOAD(1:3,1:n), Basis(1:n) )

       ! Compute element stiffness matrix and force vector:
       ! --------------------------------------------------
       DO i = 1,nd
         FORCE(i) = FORCE(i) + (SUM(L*WBasis(i,:)))* detJ*IP%s(t)

         DO j = 1,nd
           ! the mu^-1 curl u . curl v 
           STIFF(i,j) = STIFF(i,j) + muinv * &
              SUM(RotWBasis(i,:)*RotWBasis(j,:))*detJ*IP%s(t)

           ! the term \omega^2 \epsilon u.v
           STIFF(i,j) = STIFF(i,j) - Omega*Omega* &
             eps * SUM(WBasis(J,:)*WBasis(i,:))*detJ*IP%s(t)
         END DO
       END DO
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------

!-----------------------------------------------------------------------------
  SUBROUTINE LocalMatrixBC(  STIFF, FORCE, LOAD, Bcoef, Element, n, nd, PiolaVersion)
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp) :: LOAD(:,:), Bcoef(:)
    COMPLEX(KIND=dp) :: STIFF(:,:), FORCE(:)
    INTEGER :: n, nd
    TYPE(Element_t), POINTER :: Element, Parent, Edge
    LOGICAL,OPTIONAL :: PiolaVersion
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),DetJ,Normal(3)
    COMPLEX(KIND=dp) :: B, F, TC, L(3)
    REAL(KIND=dp) :: WBasis(nd,3), RotWBasis(nd,3)
    LOGICAL :: Stat
    INTEGER, POINTER :: EdgeMap(:,:)
    TYPE(GaussIntegrationPoints_t) :: IP
    INTEGER :: t, i, j, k, ii,jj, np, p, q

    TYPE(Nodes_t), SAVE :: Nodes
!------------------------------------------------------------------------------
    CALL GetElementNodes( Nodes, Element )

    STIFF = 0.0_dp
    FORCE = 0.0_dp
    MASS  = 0.0_dp

    ! Numerical integration:
    !-----------------------
    IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)
    np = n*MAXVAL(Solver % Def_Dofs(GetElementFamily(Element),:,1))

    DO t=1,IP % n
      IF(Present(PiolaVersion) .AND. PiolaVersion) THEN
        stat = EdgeElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
          IP % W(t), DetF = DetJ, Basis = Basis, EdgeBasis = WBasis, &
          RotBasis = RotWBasis, dBasisdx = dBasisdx, &
          ApplyPiolaTransform = .TRUE.)
      ELSE
        stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
          IP % W(t), detJ, Basis, dBasisdx )

        CALL GetEdgeBasis(Element, WBasis, RotWBasis, Basis, dBasisdx)
      END IF

      !Normal = NormalVector( Element, Nodes, IP % U(t), IP % V(t), .TRUE.)
      B  = SUM(Basis(1:n) * Bcoef(1:n))
      L  = MATMUL(LOAD(1:3,1:n), Basis(1:n))

      ! Compute element stiffness matrix and force vector:
      !---------------------------------------------------
      DO p=1,np
        FORCE(p) = FORCE(p) + F*Basis(p)*detJ*IP % s(t)
        DO q=1,np
          STIFF(p,q) = STIFF(p,q) + TC * &
                 Basis(p)*Basis(q)*detJ*IP % s(T)
        END DO
      END DO

      DO i = 1,nd-np
        p = i+np
         
        FORCE(p) = FORCE(p) + SUM(L*WBasis(i,:))*detJ*IP%s(t)
        DO j = 1,nd-np
          q = j+np
          STIFF(p,q) = STIFF(p,q) + B * &
             SUM(WBasis(i,:)*WBasis(j,:))*detJ*IP%s(t)
        END DO
      END DO
   END DO
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrixBC
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
 END SUBROUTINE VectorHelmholtzSolver
!------------------------------------------------------------------------------

!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE VectorHelmholtzCalcFields_Init0(Model,Solver,dt,Transient)
!------------------------------------------------------------------------------
  USE VectorHelmholtzUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------
  CHARACTER(LEN=MAX_NAME_LEN) :: sname,pname
  LOGICAL :: Found, ElementalFields
  INTEGER, POINTER :: Active(:)
  INTEGER :: mysolver,i,j,k,l,n,m,vDOFs, soln
  TYPE(ValueList_t), POINTER :: SolverParams
  TYPE(Solver_t), POINTER :: Solvers(:), PSolver

  IF (GetLogical(GetSolverParams(),'Discontinuous Galerkin',Found)) RETURN

  ElementalFields = GetLogical( GetSolverParams(), 'Calculate Elemental Fields', Found)
  IF(Found.AND..NOT.ElementalFields) RETURN

  PSolver => Solver
  DO mysolver=1,Model % NumberOfSolvers
    IF ( ASSOCIATED(PSolver,Model % Solvers(mysolver)) ) EXIT
  END DO

  n = Model % NumberOfSolvers
  DO i=1,Model % NumberOFEquations
    Active => ListGetIntegerArray(Model % Equations(i) % Values, &
                'Active Solvers', Found)
    m = SIZE(Active)
    IF ( ANY(Active==mysolver) ) &
      CALL ListAddIntegerArray( Model % Equations(i) % Values,  &
           'Active Solvers', m+1, [Active, n+1] )
  END DO

  pname = GetString(GetSolverParams(), 'Field variable', Found)
  vDOFs = 0
  DO i=1,Model % NumberOfSolvers
    sname = GetString(Model % Solvers(i) % Values, 'Variable', Found)
    J=INDEX(sname,'[')-1
    IF ( j<=0 ) j=LEN_TRIM(sname)
    IF ( sname(1:j) == pname(1:LEN_TRIM(pname)) )THEN
      k = 0
      vDOFs = 0
      j=INDEX(sname,':')
      DO WHILE(j>0)
        vDOFs=vDOFs+ICHAR(sname(j+k+1:j+k+1))-ICHAR('0')
        k = k+j
        IF(k<LEN(sname)) j=INDEX(sname(k+1:),':')
      END DO
      EXIT
    END IF
  END DO
  soln = i
  IF ( vDOFs==0 ) vDOFs=1

  ALLOCATE(Solvers(n+1))
  Solvers(1:n) = Model % Solvers
  SolverParams => NULL()
  CALL ListAddLogical( SolverParams, 'Discontinuous Galerkin', .TRUE. )
  Solvers(n+1) % Values => SolverParams
  Solvers(n+1) % PROCEDURE = 0
  Solvers(n+1) % ActiveElements => NULL()
  CALL ListAddString( SolverParams, 'Exec Solver', 'never' )
  CALL ListAddLogical( SolverParams, 'No Matrix',.TRUE.)
  CALL ListAddString( SolverParams, 'Equation', 'never' )
  CALL ListAddString( SolverParams, 'Procedure', &
              'VectorHelmholtz MagnetoDynamics_Dummy',.FALSE. )
  CALL ListAddString( SolverParams, 'Variable', '-nooutput cf_dummy' )

  pname = ListGetString( Model % Solvers(soln) % Values, 'Mesh', Found )
  IF(Found) THEN
    CALL ListAddString( SolverParams, 'Mesh', pname )
  END IF

  i = 0

  IF (GetLogical(SolverParams,'Calculate Flux Density',Found)) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
           "Magnetic Flux Density E[Magnetic Flux Density E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
           "Magnetic Flux Density E[Magnetic Flux Density re E:3 Magnetic Flux Density im E:3]" )
    END IF
  END IF

  IF (GetLogical(Solver % Values,'Calculate Electric field',Found)) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Electric field E[Electric field E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Electric field E[Electric field re E:3 Electric field im E:3]" )
    END IF
  END IF

  IF (GetLogical(Solver % Values,'Calculate Magnetic Field Strength',Found)) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Magnetic Field Strength E[Magnetic Field Strength E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Magnetic Field Strength E[Magnetic Field Strength re E:3 Magnetic Field Strength im E:3]" )
    END IF
  END IF

  IF (GetLogical(Solver % Values,'Calculate JxB',Found)) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "JxB E[JxB E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "JxB E[JxB re E:3 JxB im E:3]" )
    END IF
  END IF

  IF ( GetLogical( Solver % Values, 'Calculate Maxwell Stress', Found ) ) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
           "Maxwell Stress E[Maxwell Stress E:6]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
           "Maxwell Stress E[Maxwell Stress re E:6 Maxwell Stress im E:6]" )
    END IF
  END IF

  IF ( GetLogical( Solver % Values, 'Calculate Current Density', Found ) ) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
          "Current Density E[Current Density E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
          "Current Density E[Current Density re E:3 Current Density im E:3]" )
    END IF
  END IF

  IF ( GetLogical( Solver % Values, 'Calculate Joule Heating', Found ) ) THEN
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
        "Joule Field E" )
  END IF


  IF ( GetLogical( Solver % Values, 'Calculate Poynting vector', Found ) ) THEN
    i = i + 1
    IF ( vDOFs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
        "Poynting vector E[Poynting vector E:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
        "Poynting vector E[Poynting vector re E:3 Poynting vector im E:3]" )
    END IF
  END IF

  IF ( GetLogical( Solver % Values, 'Calculate Div of Poynting Vector', Found ) ) THEN
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Div Poynting Vector E[Div Poynting Vector re E:1 Div Poynting Vector im E:1]" )
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Electric Work E[Electric Work re E:1 Electric Work im E:1]")
  END IF

  DEALLOCATE(Model % Solvers)
  Model % Solvers => Solvers
  Model % NumberOfSolvers = n+1
!------------------------------------------------------------------------------
END SUBROUTINE VectorHelmholtzCalcFields_Init0
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
SUBROUTINE MagnetoDynamics_Dummy(Model,Solver,dt,Transient)
!------------------------------------------------------------------------------
  USE VectorHelmholtzUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------
END SUBROUTINE MagnetoDynamics_Dummy
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE VectorHelmholtzCalcFields_Init(Model,Solver,dt,Transient)
!------------------------------------------------------------------------------
  USE VectorHelmholtzUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: Transient
!------------------------------------------------------------------------------

  CHARACTER(LEN=MAX_NAME_LEN) :: name
  INTEGER  :: i
  TYPE(Variable_t), POINTER :: Var
  LOGICAL :: Found, FluxFound, NodalFields
  TYPE(ValueList_t), POINTER :: EQ, SolverParams

  SolverParams => GetSolverParams()

  CALL ListAddString( SolverParams, 'Variable', '-nooutput hr_dummy' )

  CALL ListAddLogical( SolverParams, 'Linear System refactorize', .FALSE.)

  name = GetString( SolverParams, "Field variable", Found )
  Var => VariableGet( Solver % Mesh % variables, name )
  IF ( .NOT. ASSOCIATED(Var) ) THEN
    CALL Fatal( "VectorHelmholtzCalcFields", "field variable not available")
  ENDIF

  ! add these in the beginning, so that SaveData sees these existing, even
  ! if executed before the actual computations...
  ! -----------------------------------------------------------------------
  CALL ListAddConstReal(Model % Simulation,'res: Eddy current power',0._dp)
  CALL ListAddConstReal(Model % Simulation,'res: Magnetic Field Energy',0._dp)

  IF (GetLogical(GetSolverParams(),'Show Angular Frequency',Found)) &
    CALL ListAddConstReal(Model % Simulation,'res: Angular Frequency',0._dp)

  ! add these in the beginning only if the Magnetix Flux Average is computed
  ! -------------------------------------------------------------------------
  IF (ListGetLogicalAnyBC( Model,'Magnetic Flux Average')) THEN
    CALL ListAddConstReal( Model % Simulation,'res: Magnetic Flux Average', 0._dp)
    CALL ListAddConstReal(Model % Simulation, &
                           'res: Magnetic Flux Density Average',0._dp)

    IF (Var % dofs == 2) THEN 
      CALL ListAddConstReal(Model % Simulation,'res: Magnetic Flux im Average',0._dp)
      CALL ListAddConstReal(Model % Simulation, &
                   'res: Magnetic Flux Density im Average', 0._dp )
    END IF

    CALL ListAddConstReal(Model % Simulation,'res: Magnetic Flux Area',0._dp)
  END IF

  NodalFields = GetLogical( SolverParams, 'Calculate Nodal Fields', Found)
  IF(Found.AND..NOT.NodalFields) RETURN

  i=1
  DO WHILE(.TRUE.)
    IF ( .NOT.ListCheckPresent(SolverParams, &
          "Exported Variable "//TRIM(i2s(i))) ) EXIT
    i = i + 1
  END DO

  i = i - 1
  IF (GetLogical(SolverParams,'Calculate Magnetic Flux Density',Found)) THEN
    i = i + 1
    IF ( Var % dofs == 1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
        "Magnetic Flux Density[Magnetic Flux Density:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
        "Magnetic Flux Density[Magnetic Flux Density re:3 Magnetic Flux Density im:3]" )
    END IF
  END IF

  IF (GetLogical(SolverParams,'Calculate Electric field',Found)) THEN
    i = i + 1
    IF ( Var  % dofs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Electric field[Electric field:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Electric field[Electric field re:3 Electric field im:3]")
    END IF
  END IF

  IF (GetLogical(SolverParams,'Calculate Magnetic Field Strength',Found)) THEN
    i = i + 1
    IF ( Var  % dofs==1 ) THEN
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
            "Magnetic Field Strength[Magnetic Field Strength:3]" )
    ELSE
      CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Magnetic Field Strength[Magnetic Field Strength re:3 Magnetic Field Strength im:3]")
    END IF
  END IF

  IF ( GetLogical( SolverParams, 'Calculate Poynting vector', Found ) ) THEN
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Poynting vector[Poynting vector re:3 Poynting vector im:3]" )
  END IF

  IF ( GetLogical( SolverParams, 'Calculate Div of Poynting Vector', Found ) ) THEN
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Div Poynting Vector[Div Poynting Vector re:1 Div Poynting Vector im:1]" )
    i = i + 1
    CALL ListAddString( SolverParams, "Exported Variable "//TRIM(i2s(i)), &
      "Electric Work[Electric Work re:1 Electric Work im:1]")
  END IF
!------------------------------------------------------------------------------
END SUBROUTINE VectorHelmholtzCalcFields_Init
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!> Calculate fields resulting from the edge element formulation of the magnetic 
!> field equations. 
!> \ingroup Solvers
!------------------------------------------------------------------------------
 SUBROUTINE VectorHelmholtzCalcFields(Model,Solver,dt,Transient)
!------------------------------------------------------------------------------
   USE VectorHelmholtzUtils

   IMPLICIT NONE
!------------------------------------------------------------------------------
   TYPE(Solver_t) :: Solver
   TYPE(Model_t) :: Model

   REAL(KIND=dp) :: dt
   LOGICAL :: Transient
!------------------------------------------------------------------------------
  
!------------------------------------------------------------------------------
   REAL(KIND=dp) :: s,u,v,w,WBasis(35,3), SOL(2,35), R(35), Norm, ElPotSol(1,8)
   REAL(KIND=dp) :: RotWBasis(35,3), Basis(35), dBasisdx(35,3), B(2,3), E(2,3), JatIP(2,3), &
                    VP_ip(2,3), Wbase(35), alpha(35), JXBatIP(2,3)
   REAL(KIND=dp) ::  detJ, C_ip, R_ip, ST(3,3), Omega, Power, Energy
   REAL(KIND=dp) :: Freq, FreqPower, FieldPower, ComponentLoss(2), LossCoeff, ValAtIP
   REAL(KIND=dp) :: Coeff, TotalLoss, localAlpha, localV(2)
   REAL(KIND=dp) :: Flux(2), AverageFluxDensity(2), Area, N_j, wvec(3)
   COMPLEX(KIND=dp) ::  MG_ip(3), H(3), ExHc(3), PR_ip, divS, PR(16), J_ip(3), EdotJ

   COMPLEX(KIND=dp) :: CST(3,3)
   COMPLEX(KIND=dp) :: CMat_ip(3,3)  
   COMPLEX(KIND=dp) :: imag_value

   INTEGER, PARAMETER :: ind1(6) = [1,2,3,1,2,1]
   INTEGER, PARAMETER :: ind2(6) = [1,2,3,2,3,3]

   TYPE(Variable_t), POINTER :: Var, MFD, MFS, CD, ECF, MST, &
                                JH, EF, FWP, JXB, PV, DIVPV, EW
   TYPE(Variable_t), POINTER :: EL_MFD, EL_MFS, EL_CD, EL_ECF, &
                                EL_MST, EL_JH, EL_EF, EL_FWP, &
                                EL_JXB, EL_PV, EL_DIVPV, EL_EW
                              

   INTEGER :: Active,i,j,k,l,m,n,nd,np,p,q,dofs,vDOFs,dim,BodyId,&
              VvarDofs,VvarId,IvarId,Reindex,Imindex

   TYPE(Solver_t), POINTER :: pSolver, ElPotSolver
   TYPE(Matrix_t), POINTER :: EMatrix
   TYPE(Variable_t), POINTER :: EVariable
   REAL(KIND=dp), POINTER :: xx(:), bb(:)
   REAL(KIND=dp) :: hdotE(2), hdotE_r, hdotE_i

   CHARACTER(LEN=MAX_NAME_LEN) :: Pname, CoilType, ElectricPotName, Currname

   TYPE(ValueList_t), POINTER :: Material, BC, BodyForce, BodyParams
   LOGICAL :: Found, FoundMagnetization, stat, Cubic, LossEstimation, &
              CalcFluxLogical, CoilBody, PreComputedElectricPot

   TYPE(GaussIntegrationPoints_t) :: IP
   TYPE(Nodes_t), SAVE :: Nodes
   TYPE(Element_t), POINTER :: Element

   INTEGER, ALLOCATABLE :: Pivot(:)

   REAL(KIND=dp), POINTER :: Fsave(:), HB(:,:)=>NULL(), CubicCoeff(:)=>NULL()
   REAL(KIND=dp) :: Babs
   TYPE(Mesh_t), POINTER :: Mesh
   REAL(KIND=dp), ALLOCATABLE, TARGET :: Gforce(:,:), MASS(:,:), FORCE(:,:) 
   REAL(KIND=dp), ALLOCATABLE :: BodyLoss(:), RotM(:,:,:)

   REAL(KIND=DP), POINTER :: Cwrk(:,:,:)=>NULL(), Cwrk_im(:,:,:)=>NULL()
   COMPLEX(KIND=dp), ALLOCATABLE :: Tcoef(:,:,:), Load(:,:), BndLoad(:,:)

   LOGICAL :: PiolaVersion, ElementalFields, NodalFields
   REAL(KIND=dp) :: DetF, F(3,3), G(3,3), GT(3,3)
   REAL(KIND=dp), ALLOCATABLE :: EBasis(:,:), CurlEBasis(:,:) 
   
!-------------------------------------------------------------------------------------------
   PiolaVersion = GetLogical( GetSolverParams(), &
      'Use Piola Transform', Found )
   IF (PiolaVersion) &
    CALL Info('VectorHelmholtzCalcFields', &
        'Using Piola transformed finite elements',Level=2)

   Mesh => GetMesh()

   MFD => NULL(); EL_MFD => NULL();
   MFD => VariableGet( Mesh % Variables, 'Magnetic Flux Density' )
   EL_MFD => VariableGet( Mesh % Variables, 'Magnetic Flux Density E' )

   MFS => VariableGet( Mesh % Variables, 'Magnetic Field Strength')
   EL_MFS => VariableGet( Mesh % Variables, 'Magnetic Field Strength E')

   EF => VariableGet( Mesh % Variables, 'Electric field')
   EL_EF => VariableGet( Mesh % Variables, 'Electric field E')

   PV => VariableGet( Mesh % Variables, 'Poynting vector')
   EL_PV => VariableGet( Mesh % Variables, 'Poynting vector E')

   DIVPV => VariableGet( Mesh % Variables, 'Div Poynting Vector')
   EL_DIVPV => VariableGet( Mesh % variables, 'Div Poynting Vector E')

   EW => VariableGet( Mesh % Variables, 'Electric Work')
   EL_EW => VariableGet( Mesh % Variables, 'Electric Work E')

   Pname = GetString(GetSolverParams(), 'Field Variable')
   DO i=1,Model % NumberOfSolvers
     pSolver => Model % Solvers(i)
     IF (Pname==getVarName(pSolver % Variable)) EXIT
   END DO
   vDOFs = pSolver % Variable % dofs
 
   ECF => NULL(); EL_ECF => NULL(); 
   CD => NULL(); EL_CD => NULL();
   JH => NULL(); EL_JH => NULL();
   FWP => NULL(); EL_FWP => NULL();
   JXB => NULL(); EL_JXB => NULL();

   MST => variableGet( Mesh % Variables, 'Maxwell stress' )
   EL_MST => variableGet( Mesh % Variables, 'Maxwell stress E' )

   dofs = 0 
   IF ( ASSOCIATED(MFD) ) dofs=dofs+3
   IF ( ASSOCIATED(MFS) ) dofs=dofs+3
   IF ( ASSOCIATED(EF)  ) dofs=dofs+3
   IF ( ASSOCIATED(CD)  ) dofs=dofs+3
   IF ( ASSOCIATED(FWP) ) dofs=dofs+1
   IF ( ASSOCIATED(ECF) ) dofs=dofs+3
   IF ( ASSOCIATED(JXB) ) dofs=dofs+3
   IF ( ASSOCIATED(MST) ) dofs=dofs+6
   IF ( ASSOCIATED(PV) ) dofs=dofs+3
   IF ( ASSOCIATED(DIVPV) ) dofs=dofs+1
   IF ( ASSOCIATED(EW) ) dofs=dofs+1
   dofs = dofs*2  ! complex problem
   IF ( ASSOCIATED(JH) ) dofs=dofs+1
   NodalFields = dofs>0

   IF(NodalFields) THEN
     ALLOCATE(GForce(SIZE(Solver % Matrix % RHS),dofs)); Gforce=0._dp
   ELSE
     dofs = 0 
     IF ( ASSOCIATED(EL_MFD) ) dofs=dofs+3
     IF ( ASSOCIATED(EL_MFS) ) dofs=dofs+3
     IF ( ASSOCIATED(EL_EF)  ) dofs=dofs+3
     IF ( ASSOCIATED(EL_CD)  ) dofs=dofs+3
     IF ( ASSOCIATED(EL_FWP) ) dofs=dofs+1
     IF ( ASSOCIATED(EL_ECF) ) dofs=dofs+3
     IF ( ASSOCIATED(EL_JXB) ) dofs=dofs+3
     IF ( ASSOCIATED(EL_MST) ) dofs=dofs+6
     IF ( ASSOCIATED(EL_PV) )  dofs=dofs+3
     IF ( ASSOCIATED(EL_DIVPV) ) dofs=dofs+1
     IF ( ASSOCIATED(EL_EW) ) dofs=dofs+1
     dofs = dofs*2 ! complex problem
     IF ( ASSOCIATED(EL_JH) ) dofs=dofs+1
   END IF

   ElementalFields = .FALSE.
   IF ( ASSOCIATED(EL_MFD) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_MFS) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_EF)  ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_CD)  ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_FWP) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_ECF) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_JXB) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_MST) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_JH) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_DIVPV) ) ElementalFields=.TRUE.
   IF ( ASSOCIATED(EL_PV) ) ElementalFields=.TRUE.

   n = Mesh % MaxElementDOFs

   ALLOCATE( MASS(n,n), FORCE(n,dofs), Tcoef(3,3,n), RotM(3,3,n), Pivot(n), Load(3,n), BndLoad(3,n) )
   IF (PiolaVersion) ALLOCATE( EBasis(n,3), CurlEBasis(n,3) )

   SOL = 0._dp

   R=0._dp; PR=0._dp

   Power = 0._dp; Energy = 0._dp

   xx => pSolver % Variable % Values
   bb => pSolver % Matrix % RHS

   hdotE = 0._dp
   DO i = 1, size(xx,1)/2   ! \TODO this assumes that each edge belongs to only one PE
     hdotE = hdotE + [ xx(2*(i-1)+1) * bb(2*(i-1)+1) - &
                       xx(2*(i-1)+2) * bb(2*(i-1)+2), &
                       xx(2*(i-1)+1) * bb(2*(i-1)+2) + &
                       xx(2*(i-1)+2) * bb(2*(i-1)+1) ]
   END DO
   hdotE_r = ParallelReduction(hdotE(1))
   hdotE_i = ParallelReduction(hdotE(2))
   write (*,*), 'hdotE = ', hdotE

   CALL DefaultInitialize()
   DO i = 1, GetNOFActive()
     Element => GetActiveElement(i)
     n = GetElementNOFNodes()
     np = n*pSolver % Def_Dofs(GetElementFamily(Element),Element % BodyId,1)
     nd = GetElementNOFDOFs(uSolver=pSolver)

     CALL GetElementNodes( Nodes )

     CALL GetVectorLocalSolution(SOL,Pname,uSolver=pSolver)

     Load = 0._dp
     BodyForce => GetBodyForce(Element)

     Omega = GetAngularFrequency(Found=Found,UElement=Element)
     Freq = Omega / (2*PI)

     BodyId = GetBody()
     Material => GetMaterial()

     CALL GetPermittivity(Material,PR,n)

     CALL GetInvPermeability(Material,R,n)

     dim = 3

     ! Fetch impressed current density:
     ! --------------------------------
     IF ( ASSOCIATED(BodyForce) ) THEN
       Load(1,1:n) = GetReal( BodyForce, 'Current Density 1', Found )
       Load(1,1:n) = CMPLX( REAL(Load(1,1:n)), &
         GetReal( BodyForce, 'Current Density im 1', Found ), KIND=dp)

       Load(2,1:n) = GetReal( BodyForce, 'Current Density 2', Found )
       Load(2,1:n) = CMPLX( REAL(Load(2,1:n)), & 
         GetReal( BodyForce, 'Current Density im 2', Found), KIND=dp)

       Load(3,1:n) = GetReal( BodyForce, 'Current Density 3', Found )
       Load(3,1:n) = CMPLX( REAL(Load(3,1:n)), &
         GetReal( BodyForce, 'Current Density im 3', Found), KIND=dp)
     END IF

     ! Calculate nodal fields:
     ! -----------------------
     IP = GaussPoints(Element, EdgeBasis=.TRUE., PReferenceElement=PiolaVersion)

     MASS  = 0._dp
     FORCE = 0._dp
     E = 0._dp; B=0._dp
     DO j = 1,IP % n
       u = IP % U(j)
       v = IP % V(j)
       w = IP % W(j)

       IF (PiolaVersion) THEN
          stat = EdgeElementInfo( Element, Nodes, u, v, w, &
               F, G, DetJ, Basis, WBasis, RotWBasis, dBasisdx, ApplyPiolaTransform=.TRUE.)
          !stat = EdgeElementInfo( Element, Nodes, u, v, w, &
               !F, G, DetF, Basis, EBasis, CurlEBasis, dBasisdx)

          !-------------------------------------------------------------------------
          ! Apply the Piola transformation so that WBasis(j,:) gives the jth basis
          ! vector B_j(x), with the place x related to the reference element 
          ! coordinates p via the element mapping x = f(p). Additionally, 
          ! RotWBasis(j,:) gives (curl B_j)(f(p)) where curl is the spatial curl.
          !-------------------------------------------------------------------------
          !GT(1:dim,1:dim) = TRANSPOSE(G(1:dim,1:dim))
          !DO l = 1,nd-np 
             !DO k=1,dim
                !WBasis(l,k) = SUM( GT(k,1:dim) * EBasis(l,1:dim) )
                !RotWBasis(l,k) = 1.0d0/DetF * SUM( F(k,1:dim) * CurlEBasis(l,1:dim) )
             !END DO
          !END DO
          !DetJ = ABS(DetF)
       ELSE
          stat=ElementInfo(Element,Nodes,u,v,w,detJ,Basis,dBasisdx)
          CALL GetEdgeBasis(Element,WBasis,RotWBasis,Basis,dBasisdx)
       END IF

       !IF (ASSOCIATED(MFD)) THEN
       B(1,:) = MATMUL( SOL(2,np+1:nd), RotWBasis(1:nd-np,:) ) / (Omega)
       B(2,:) = MATMUL( SOL(1,np+1:nd), RotWBasis(1:nd-np,:) ) / (-Omega)
       !END IF

        J_ip(:) = MATMUL(Load(:,1:n),Basis(1:n))

       !-------------------------------
       ! The conductivity as a tensor
       ! -------------------------------
       !C_ip  = SUM( Basis(1:n)*C(1:n) )
       DO k=1,3
         DO l=1,3
           CMat_ip(k,l) = SUM( Tcoef(k,l,1:n) * Basis(1:n) )
         END DO
       END DO

       !IF ( ASSOCIATED(MFS).OR.ASSOCIATED(EL_MFS) ) THEN
         R_ip = SUM( Basis(1:n)*R(1:n) )
         H = R_ip*CMPLX(B(1,:), B(2,:), KIND=dp)
       !END IF


       PR_ip = SUM( Basis(1:n)*PR(1:n) )

       !IF( ASSOCIATED(EF).OR.ASSOCIATED(EL_EF) ) THEN
         DO l=1,vDOFs
           VP_ip(l,:)=MATMUL(SOL(l,np+1:nd),WBasis(1:nd-np,:))
         END DO
       !END IF

       !IF ( ASSOCIATED(PV).OR.ASSOCIATED(EL_PV) ) THEN
         ExHc = ComplexCrossProduct(CMPLX(VP_ip(1,:),VP_ip(2,:), KIND=dp), CONJG(H))
       !END IF

       !IF ( ASSOCIATED(DIVPV) .OR. ASSOCIATED(EL_DIVPV) ) THEN ! \TODO make B and VP_ip complex variables and rename VP_ip -> E
         EdotJ = SUM(CMPLX(VP_ip(1,:), VP_ip(2,:), KIND=dp)*CONJG(J_IP))
         divS = CMPLX(0,1,KIND=dp) * Omega * 0.5_dp * (SUM(CMPLX(B(1,:), B(2,:), KIND=dp)*CONJG(H)) + &
                                         SUM(CMPLX(VP_ip(1,:), VP_ip(2,:), KIND=dp) * CONJG(PR_ip * &
                                                  CMPLX(VP_ip(1,:), VP_ip(2,:), KIND=dp)))) + EdotJ
       !END IF

       s = IP % s(j) * detJ

       !Power = Power + SUM(E**2)*C_ip*s
       IF (vDOFs == 1) THEN
          Power = Power + SUM( MATMUL( REAL(CMat_ip(1:dim,1:dim)), TRANSPOSE(E(1:1,1:dim)) ) * &
               TRANSPOSE(E(1:1,1:dim)) ) * s
       ELSE
          ! Now Power = J.conjugate(E), with the possible imaginary component neglected.
          ! Perhaps we should set Power = 1/2 J.conjugate(E) so that the average power
          ! would be obtained.
          Power = Power + SUM( MATMUL( REAL(CMat_ip(1:dim,1:dim)), TRANSPOSE(E(1:1,1:dim)) ) * &
               TRANSPOSE(E(1:1,1:dim)) ) * s - &
               SUM( MATMUL( AIMAG(CMat_ip(1:dim,1:dim)), TRANSPOSE(E(2:2,1:dim)) ) * &
               TRANSPOSE(E(1:1,1:dim)) ) * s + &
               SUM( MATMUL( AIMAG(CMat_ip(1:dim,1:dim)), TRANSPOSE(E(1:1,1:dim)) ) * &
               TRANSPOSE(E(2:2,1:dim)) ) * s + &               
               SUM( MATMUL( REAL(CMat_ip(1:dim,1:dim)), TRANSPOSE(E(2:2,1:dim)) ) * &
               TRANSPOSE(E(2:2,1:dim)) ) * s
       END IF

       Energy = Energy + s*(REAL(PR_ip)*SUM(E**2) + R_ip*SUM(B**2))/2
       DO p=1,n
         DO q=1,n
           MASS(p,q)=MASS(p,q)+s*Basis(p)*Basis(q)
         END DO
         k = 0
         IF (ASSOCIATED(MFD) .OR. ASSOCIATED(EL_MFD)) THEN
           DO l=1,vDOFs
             FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+s*B(l,:)*Basis(p)
             k = k+3
           END DO
         END IF
         IF ( ASSOCIATED(MFS).OR.ASSOCIATED(EL_MFS)) THEN
           FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+s*(R_ip*B(1,:)) ! \TODO: only real muinv supported
           k = k+3
           IF ( vDOFs>1 ) THEN
             FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+s*(R_ip*B(2,:)) ! \TODO: only real muinv supported
             k = k+3
           END IF
         END IF
         IF ( ASSOCIATED(EF).OR.ASSOCIATED(EL_EF)) THEN
             FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+s*VP_ip(1,:)*Basis(p)
             k = k+3
             FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+s*VP_ip(2,:)*Basis(p)
             k = k+3
         END IF
         IF ( ASSOCIATED(PV).OR.ASSOCIATED(EL_PV)) THEN
           FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+0.5_dp*s*REAL(ExHc)*Basis(p)
           k = k+3
           FORCE(p,k+1:k+3) = FORCE(p,k+1:k+3)+0.5_dp*s*AIMAG(ExHc)*Basis(p)
           k = k+3
         END IF
         IF ( ASSOCIATED(DIVPV) .OR. ASSOCIATED(EL_DIVPV)) THEN
           FORCE(p,k+1) = FORCE(p,k+1) + s*REAL(divS)*Basis(p)
           k=k+1
           FORCE(p,k+1) = FORCE(p,k+1) + s*AIMAG(divS)*Basis(p)
           k=k+1
           FORCE(p,k+1) = FORCE(p,k+1) + s*REAL(EdotJ)*Basis(p)
           k=k+1
           FORCE(p,k+1) = FORCE(p,k+1) + s*AIMAG(EdotJ)*Basis(p)
           k=k+1
         END IF

       END DO
     END DO

     IF(NodalFields) THEN
       CALL DefaultUpdateEquations( MASS,FORCE(:,1))
       Fsave => Solver % Matrix % RHS
       DO l=1,dofs
         Solver % Matrix % RHS => GForce(:,l)
         CALL DefaultUpdateForce(FORCE(:,l))
       END DO
       Solver % Matrix % RHS => Fsave
     END IF

     IF(ElementalFields) THEN
       dofs = 0
       CALL LUdecomp(MASS,n,pivot)
       CALL LocalSol(EL_MFD,  6, n, MASS, FORCE, pivot, dofs) ! 2*3 components
       CALL LocalSol(EL_MFS,  6, n, MASS, FORCE, pivot, dofs)
       CALL LocalSol(EL_EF,   6, n, MASS, FORCE, pivot, dofs)
       CALL LocalSol(EL_PV,   6, n, MASS, FORCE, pivot, dofs)
       CALL LocalSol(EL_DIVPV,2, n, MASS, FORCE, pivot, dofs)
       CALL LocalSol(EL_EW,   2, n, MASS, FORCE, pivot, dofs)
       !CALL LocalSol(EL_JXB,  3*vDOFs, n, MASS, FORCE, pivot, dofs)
       !CALL LocalSol(EL_FWP,  1*vDOFs, n, MASS, FORCE, pivot, dofs)
       !CALL LocalSol(EL_JH,   1, n, MASS, FORCE, pivot, dofs)
       !CALL LocalSol(EL_MST,  6*vDOFs, n, MASS, FORCE, pivot, dofs)
     END IF

   END DO

   Power  = ParallelReduction(Power)
   Energy = ParallelReduction(Energy)

    ! Assembly of the face terms:
    !----------------------------

    IF (GetLogical(GetSolverParams(),'Discontinuous Galerkin',Found)) THEN
      IF (GetLogical(GetSolverParams(),'Average Within Materials',Found)) THEN
        FORCE = 0.0_dp
        CALL AddLocalFaceTerms( MASS, FORCE(:,1) )
      END IF
    END IF

   IF(NodalFields) THEN
     Fsave => Solver % Matrix % RHS
     dofs = 0
     CALL GlobalSol(MFD,  6, Gforce, dofs)
     CALL GlobalSol(MFS,  6, Gforce, dofs)
     CALL GlobalSol(EF ,  6, Gforce, dofs)
     CALL GlobalSol(PV,   6, Gforce, dofs)
     CALL GlobalSol(DIVPV,2, Gforce, dofs)
     CALL GlobalSol(EW,   2, Gforce, dofs)
     !CALL GlobalSol(JXB,  3*vDOFs, Gforce, dofs)
     !CALL GlobalSol(FWP,  1*vDOFs, Gforce, dofs)
     !CALL GlobalSol(JH ,  1      , Gforce, dofs)
     !CALL GlobalSol(MST , 6*vDOFs, Gforce, dofs)
     Solver % Matrix % RHS => Fsave
   END IF

   WRITE(Message,*) 'Eddy current power: ', Power
   CALL Info( 'MagnetoDynamics', Message )
   CALL ListAddConstReal( Model % Simulation, 'res: Eddy current power', Power )

   WRITE(Message,*) '(Electro)Magnetic Field Energy: ', Energy
   CALL Info( 'MagnetoDynamics', Message )
   CALL ListAddConstReal(Model % Simulation,'res: Magnetic Field Energy',Energy)

   IF(ALLOCATED(Gforce)) DEALLOCATE(Gforce)
   DEALLOCATE( MASS,FORCE,Tcoef,RotM )
   IF (PiolaVersion) DEALLOCATE( EBasis, CurlEBasis )

   IF (LossEstimation) THEN
      CALL ListAddConstReal( Model % Simulation,'res: fourier loss',TotalLoss )

      WRITE( Message,'(A,ES12.3)') 'Loss for cos mode: ', ComponentLoss(1)
      CALL Info('MagnetoDynamics', Message, Level=6 )
      WRITE( Message,'(A,ES12.3)') 'Loss for sin mode: ', ComponentLoss(2)
      CALL Info('MagnetoDynamics', Message, Level=6 )
      WRITE( Message,'(A,ES12.3)') 'Total loss: ',TotalLoss
      CALL Info('MagnetoDynamics',Message, Level=5 )

      CALL Info('FourierLosses','Losses by bodies',Level=6)
      DO j=1,Model % NumberOfBodies
         IF( BodyLoss(j) < TINY( TotalLoss ) ) CYCLE
         WRITE( Message,'(A,I0,A,ES12.3)') 'Body ',j,' : ',BodyLoss(j)
         CALL Info('MagnetoDynamics', Message, Level=6 )
      END DO
 
      DEALLOCATE( BodyLoss )      
   END IF
      
  IF (GetLogical(GetSolverParams(),'Show Angular Frequency',Found)) THEN
    WRITE(Message,*) 'Angular Frequency: ', Omega
    CALL Info( 'MagnetoDynamics', Message )
    CALL ListAddConstReal(Model % Simulation,'res: Angular Frequency', Omega)
  END IF

  ! Flux On Boundary:
  !------------------

  CalcFluxLogical = .FALSE.
  Flux = 0._dp
  Area = 0._dp
  AverageFluxDensity = 0._dp

  IF (ListGetLogicalAnyBC( Model,'Magnetic Flux Average')) THEN
    IF (PiolaVersion) THEN
         CALL Warn('VectorHelmholtzCalcFields', &
          'Magnetic Flux Average: The feature is not yet available for Piola transformed basis functions')
    ELSE
    DO i=1,GetNOFBoundaryElements()
       Element => GetBoundaryElement(i)
       IF (.NOT. ActiveBoundaryElement()) CYCLE
       BC=>GetBC()
       IF (.NOT. ASSOCIATED(BC) ) CYCLE
     
       SELECT CASE(GetElementFamily())
       CASE(1)
         CYCLE
       CASE(2)
         k = GetBoundaryEdgeIndex(Element,1); Element => Mesh % Edges(k)
       CASE(3,4)
         k = GetBoundaryFaceIndex(Element)  ; Element => Mesh % Faces(k)
       END SELECT

       IF (ASSOCIATED(Element % BoundaryInfo % Right)) THEN
         BodyId = Element % BoundaryInfo % Right % BodyID       
       ELSE IF (ASSOCIATED(Element % BoundaryInfo % Left)) THEN
         BodyId = Element % BoundaryInfo % Left % BodyID
       ELSE 
         CALL Fatal ('VectorHelmholtzCalcFields', 'Magnetic Flux Average: Boundary Element has not got a parent element.')
       END IF

       n = GetElementNOFNodes()
       np = n*pSolver % Def_Dofs(GetElementFamily(Element),BodyId,1)
       nd = GetElementNOFDOFs(uElement=Element, uSolver=pSolver)
       CALL GetVectorLocalSolution(SOL,Pname,uElement=Element,uSolver=pSolver)

       CalcFluxLogical = GetLogical( BC, 'Magnetic Flux Average', Found)
       IF (Found .AND. CalcFluxLogical) CALL calcAverageFlux(Flux, Area, Element, n, nd, np, SOL, vDOFs)
    END DO
    Flux(1) = ParallelReduction(Flux(1))
    Flux(2) = ParallelReduction(Flux(2))
    Area = ParallelReduction(Area)

    IF( Area < EPSILON( Area ) ) THEN
      CALL WARN('VectorHelmholtzCalcFields', 'Magnetic Flux Average Computation: Area < Epsilon(Area)')
      RETURN
    END IF

    AverageFluxDensity = Flux / Area
 
    WRITE(Message,*) 'Magnetic Flux Average: ', Flux(1)
    CALL Info( 'MagnetoDynamics', Message )
    CALL ListAddConstReal( Model % Simulation, 'res: Magnetic Flux Average', Flux(1) )
 
    IF (vDOFs == 2) THEN 
      WRITE(Message,*) 'Magnetic Flux im Average: ', Flux(2)
      CALL Info( 'MagnetoDynamics', Message )
      CALL ListAddConstReal( Model % Simulation, 'res: Magnetic Flux im Average', Flux(2) )
    END IF

    WRITE(Message,*) 'Magnetic Flux Density Average: ', AverageFluxDensity(1)
    CALL Info( 'MagnetoDynamics', Message )
    CALL ListAddConstReal( Model % Simulation,'res: Magnetic Flux Density Average', &
                          AverageFluxDensity(1))

    IF (vDOFs == 2) THEN 
     WRITE(Message,*) 'Magnetic Flux Density im Average: ', AverageFluxDensity(2)
     CALL Info( 'MagnetoDynamics', Message )
     CALL ListAddConstReal( Model % Simulation,'res: Magnetic Flux Density im Average', &
                          AverageFluxDensity(2))
    END IF

    WRITE(Message,*) 'Magnetic Flux Area: ', Area
    CALL Info( 'MagnetoDynamics', Message )
    CALL ListAddConstReal( Model % Simulation,'res: Magnetic Flux Area', Area )
    END IF
  END IF


CONTAINS

 
!------------------------------------------------------------------------------
 SUBROUTINE GlobalSol(Var, m, b, dofs )
!------------------------------------------------------------------------------
   REAL(KIND=dp), TARGET :: b(:,:)
   INTEGER :: m, dofs
   TYPE(Variable_t), POINTER :: Var
!------------------------------------------------------------------------------
   INTEGER :: i
!------------------------------------------------------------------------------
   IF(.NOT. ASSOCIATED(var)) RETURN

   DO i=1,m
     dofs = dofs+1
     Solver % Matrix % RHS => b(:,dofs)
     Solver % Variable % Values=0
     Norm = DefaultSolve()
     var % Values(i::m) = Solver % Variable % Values
   END DO
!------------------------------------------------------------------------------
 END SUBROUTINE GlobalSol
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
 SUBROUTINE LocalSol(Var, m, n, A, b, pivot, dofs )
!------------------------------------------------------------------------------
   TYPE(Variable_t), POINTER :: Var
   INTEGER :: pivot(:), m,n,dofs
   REAL(KIND=dp) :: b(:,:), A(:,:)
!------------------------------------------------------------------------------
   INTEGER :: ind(n), i
   REAL(KIND=dp) :: x(n)
!------------------------------------------------------------------------------
   IF(.NOT. ASSOCIATED(var)) RETURN

   ind = Var % dofs*(Var % Perm(Element % DGIndexes(1:n))-1)
   DO i=1,m
      dofs = dofs+1
      x = b(1:n,dofs)
      CALL LUSolve(n,MASS,x,pivot)
      Var % Values(ind(1:n)+i) = x
   END DO
!------------------------------------------------------------------------------
 END SUBROUTINE LocalSol
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddLocalFaceTerms(STIFF,FORCE)
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: STIFF(:,:), FORCE(:)

     TYPE(Element_t),POINTER :: P1,P2,Face,Faces(:)
     INTEGER ::t,n,n1,n2,NumberOfFaces,dim

     dim = CoordinateSystemDimension()

     IF (dim==2) THEN
       Faces => Solver % Mesh % Edges
       NumberOfFaces = Solver % Mesh % NumberOfEdges
     ELSE
       Faces => Solver % Mesh % Faces
       NumberOfFaces = Solver % Mesh % NumberOfFaces
     END IF

     DO t=1,NumberOfFaces
       Face => Faces(t)
       IF ( .NOT. ActiveBoundaryElement(Face) ) CYCLE

       P1 => Face % BoundaryInfo % Left
       P2 => Face % BoundaryInfo % Right
       IF ( ASSOCIATED(P2) .AND. ASSOCIATED(P1) ) THEN
          IF(.NOT.ASSOCIATED(GetMaterial(P1),GetMaterial(P2))) CYCLE

          n  = GetElementNOFNodes(Face)
          n1 = GetElementNOFNodes(P1)
          n2 = GetElementNOFNodes(P2)

          CALL LocalJumps( STIFF,Face,n,P1,n1,P2,n2)
          CALL DefaultUpdateEquations( STIFF, FORCE, Face )
       END IF
     END DO
!------------------------------------------------------------------------------
  END SUBROUTINE AddLocalFaceTerms
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
    SUBROUTINE LocalJumps( STIFF,Face,n,P1,n1,P2,n2)
!------------------------------------------------------------------------------
      IMPLICIT NONE
      REAL(KIND=dp) :: STIFF(:,:)
      INTEGER :: n,n1,n2
      TYPE(Element_t), POINTER :: Face, P1, P2
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: FaceBasis(n), P1Basis(n1), P2Basis(n2)
      REAL(KIND=dp) :: Jump(n1+n2), detJ, U, V, W, S
      LOGICAL :: Stat
      INTEGER :: i, j, p, q, t, nFace, nParent
      TYPE(GaussIntegrationPoints_t) :: IntegStuff

      TYPE(Nodes_t) :: FaceNodes, P1Nodes, P2Nodes
      SAVE FaceNodes, P1Nodes, P2Nodes
!------------------------------------------------------------------------------
      STIFF = 0._dp

      CALL GetElementNodes(FaceNodes, Face)
      CALL GetElementNodes(P1Nodes, P1)
      CALL GetElementNodes(P2Nodes, P2)
!------------------------------------------------------------------------------
!     Numerical integration over the edge
!------------------------------------------------------------------------------
      IntegStuff = GaussPoints( Face )

      DO t=1,IntegStuff % n
        U = IntegStuff % u(t)
        V = IntegStuff % v(t)
        W = IntegStuff % w(t)
        S = IntegStuff % s(t)

        ! Basis function values & derivatives at the integration point:
        !--------------------------------------------------------------
        stat = ElementInfo(Face, FaceNodes, U, V, W, detJ, FaceBasis)

        S = S * detJ

        ! Find basis functions for the parent elements:
        ! ---------------------------------------------
        CALL GetParentUVW(Face, n, P1, n1, U, V, W, FaceBasis)
        stat = ElementInfo(P1, P1Nodes, U, V, W, detJ, P1Basis)

        CALL GetParentUVW(Face, n, P2, n2, U, V, W, FaceBasis)
        stat = ElementInfo(P2, P2Nodes, U, V, W, detJ, P2Basis)

        ! Integrate jump terms:
        ! ---------------------
        Jump(1:n1) = P1Basis(1:n1)
        Jump(n1+1:n1+n2) = -P2Basis(1:n2)

        DO p=1,n1+n2
          DO q=1,n1+n2
            STIFF(p,q) = STIFF(p,q) + s * Jump(q)*Jump(p)
          END DO
        END DO
      END DO
!------------------------------------------------------------------------------
    END SUBROUTINE LocalJumps
!------------------------------------------------------------------------------


    SUBROUTINE calcAverageFlux (Flux, Area, Element, n, nd, np, SOL, vDOFs)
       INTEGER :: n, nd
       TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
       REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),DetJ,L(3),Normal(3)
       REAL(KIND=dp) :: WBasis(nd,3), RotWBasis(nd,3), B(2, 3), &
                        SOL(2,32), Flux(2), Area
       LOGICAL :: Stat
       TYPE(GaussIntegrationPoints_t) :: IP
       INTEGER :: j, k, np, vDOFs

       TYPE(Nodes_t), SAVE :: Nodes
!------------------------------------------------------------------------------
       CALL GetElementNodes( Nodes )
       IP = GaussPoints(Element)

       B=0._dp

       DO j=1,IP % n
         stat = ElementInfo( Element, Nodes, IP % U(j), IP % V(j), &
                  IP % W(j), detJ, Basis, dBasisdx )
         CALL GetEdgeBasis(Element, WBasis, RotWBasis, Basis, dBasisdx)
         Normal = NormalVector( Element, Nodes, IP % U(j), IP % V(j), .TRUE. )

         s = IP % s(j) * detJ

         DO k=1, vDOFs
           B(k,:) = MATMUL( SOL(k, np+1:nd), RotWBasis(1:nd-np,:) )
           Flux(k) = Flux(k) + s * SUM(Normal * B(k,:))
         END DO  

         Area = Area + s

      END DO

    END SUBROUTINE calcAverageFlux

!------------------------------------------------------------------------
END SUBROUTINE VectorHelmholtzCalcFields
!------------------------------------------------------------------------

